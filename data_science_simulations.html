<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…ÙƒØªØ¨Ø© Ù…Ø­Ø§ÙƒØ§Ø© Ø¹Ù„Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</title>
    
    <!-- Ø¬Ù„Ø¨ Ø§Ù„Ø®Ø·ÙˆØ· --><link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+Arabic:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø«ÙŠÙ… Ø§Ù„Ù…ÙˆØ­Ø¯ */
            --bg-dark: #2a303c;
            --card-dark: #364152;
            --text-light: #e5e7eb;
            --text-muted: #9ca3af;
            --border-color: #4b5563;
            --accent-blue: #3b82f6; /* Ù„ÙˆÙ† Ø±Ø¦ÙŠØ³ÙŠ */
            
            /* Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª */
            --cluster-1: #34D399; /* Ø£Ø®Ø¶Ø± (Ù„Ù„ÙØ¦Ø© 1 ÙˆÙ„Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¬ÙŠØ¯) */
            --cluster-2: #F87171; /* Ø£Ø­Ù…Ø± (Ù„Ù„ÙØ¦Ø© 0 ÙˆÙ„Ù„ØªØ­ÙŠØ² Ø§Ù„Ø¹Ø§Ù„ÙŠ) */
            --cluster-3: #FBBF24; /* Ø£ØµÙØ± (Ù„ØªØ¨Ø§ÙŠÙ† Ø§Ù„Ø¹Ø§Ù„ÙŠ) */
            --data-point-color: #60a5fa; /* Ø£Ø²Ø±Ù‚ */
            --item-bg: #4b5563; /* Ù„ÙˆÙ† Ø®Ù„ÙÙŠØ© Ø§Ù„Ø¹Ù†Ø§ØµØ± */
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-light);
            font-family: 'Tajawal', 'Noto Sans Arabic', 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 2rem;
            box-sizing: border-box;
            line-height: 1.8;
            font-size: 1.1rem;
        }

        .back-button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-blue);
            text-decoration: none;
            font-weight: 600;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
        }

        .back-button:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }

        .back-button svg {
            width: 1.25rem;
            height: 1.25rem;
        }

        .dashboard-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 1rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        h1 {
            font-size: 2.25rem;
            font-weight: 700;
            margin-top: 0;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 0.5rem;
            color: var(--text-light);
        }
        
        h3 {
             font-size: 1.25rem;
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        p {
            color: var(--text-muted);
            margin-bottom: 1.5rem;
            font-size: 1rem;
            line-height: 1.6;
        }

        /* --- Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ†Ù‚Ù„ (Tabs) --- */
        .tab-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 2rem;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 1rem;
        }
        
        .tab-btn {
            background-color: var(--item-bg, #4b5563);
            border: 1px solid var(--border-color);
            color: var(--text-light);
            border-radius: 0.5rem;
            padding: 0.6rem 1rem;
            font-size: 0.875rem;
            font-family: 'Noto Sans Arabic', 'Inter', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        
        .tab-btn:hover {
            background-color: #525f73;
        }
        
        .tab-btn.active {
            background-color: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        /* Ø­Ø§ÙˆÙŠØ§Øª Ø§Ù„Ù…Ø­ØªÙˆÙ‰ */
        .tab-content {
            border-radius: 0.5rem;
        }
        
        .tab-pane {
            display: none;
            animation: fadeIn 0.5s;
        }
        
        .tab-pane.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* --- Ø£Ù†Ù…Ø§Ø· Ø¹Ø§Ù…Ø© Ù„Ù„Ù…Ø­Ø§ÙƒØ§Ø© --- */
        .simulation-container {
            background-color: var(--card-dark);
            border-radius: 1rem;
            padding: 2rem;
            margin: 2rem 0;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            min-height: 500px;
            display: flex;
            flex-direction: column;
        }

        .simulation-svg {
            width: 100%;
            height: 400px;
            display: block;
        }
        
        .simulation-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        
        .sim-btn {
            background-color: var(--accent-blue);
            color: white;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1rem;
            font-family: 'Noto Sans Arabic', 'Inter', sans-serif;
            transition: background-color 0.2s;
        }
        .sim-btn:hover {
            background-color: #2563eb;
        }
        .sim-btn.secondary {
            background-color: var(--item-bg, #4b5563);
        }
        .sim-btn.secondary:hover {
             background-color: #525f73;
        }
         .sim-btn.danger {
            background-color: #dc2626; /* Ø£Ø­Ù…Ø± */
        }
        .sim-btn.danger:hover {
            background-color: #b91c1c;
        }
        
        .sim-btn:disabled {
            background-color: #4b5563;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        /* --- Ø£Ù†Ù…Ø§Ø· Ø®Ø§ØµØ© Ù„ÙƒÙ„ Ù…Ø­Ø§ÙƒØ§Ø© (Ù…ÙÙ„Ø®ØµØ©) --- */

        /* 1. K-Means */
        .centroid {
            stroke-width: 4px;
            stroke: white;
            opacity: 0.8;
        }
        .cluster-area {
            opacity: 0.2;
        }

        /* 2. Classification */
        .class-decision-boundary {
            stroke: var(--accent-blue);
            stroke-width: 4px;
            stroke-dasharray: 8 8;
        }

        /* 3. Regression */
        .reg-line {
            stroke: var(--accent-blue);
            stroke-width: 4px;
        }
        .reg-point {
            fill: var(--data-point-color);
        }

        /* 4. Dimensionality Reduction */
        .dim-red-layout {
            display: grid;
            grid-template-columns: 1fr 1.5fr; /* 2D projections on left, main 2D view on right */
            grid-template-rows: 1fr 1fr;
            gap: 1.5rem;
            height: 500px;
        }
        .dim-red-box {
            background-color: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1.25rem;
            position: relative;
            display: flex; /* Use flex to make SVG fill available space */
            flex-direction: column;
        }
        .dim-red-box.main-view {
            grid-row: span 2; /* Main view takes up two rows */
            display: flex;
            flex-direction: column;
        }
        .dim-red-svg {
            width: 100%;
            flex-grow: 1; /* SVG ÙŠÙ…Ù„Ø£ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ© */
        }
        .dim-red-box .dim-red-label {
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 0.8rem;
            color: var(--text-muted);
            font-weight: 600;
            background-color: var(--bg-dark); /* Ø®Ù„ÙÙŠØ© Ù„Ø¶Ù…Ø§Ù† Ø§Ù„ÙˆØ¶ÙˆØ­ */
            padding: 0 0.25rem;
        }

        /* 5. Association Rules */
        .assoc-layout {
            display: grid;
            gap: 1.5rem;
        }
        .assoc-box {
            background-color: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem;
        }
        .assoc-item-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
        }
        .assoc-item-btn {
            background-color: var(--item-bg, #4b5563);
            border: 1px solid var(--border-color);
            color: var(--text-light);
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            font-size: 1.5rem;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }
        .assoc-item-btn:hover { background-color: #525f73; }
        .assoc-item-btn:active { transform: scale(0.95); }
        
        #assoc-cart-items {
            font-size: 2.5rem;
            min-height: 50px;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background-color: var(--card-dark);
            margin-bottom: 1rem;
        }
        #assoc-suggestion-box {
            min-height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1rem;
            color: var(--text-muted);
            border-radius: 0.5rem;
            background-color: var(--card-dark);
            padding: 1rem;
            text-align: center;
            transition: background-color 0.3s, border-color 0.3s;
        }
        #assoc-suggestion-box.active {
            color: var(--text-light);
            background-color: #2a4a7d;
            border: 1px solid var(--accent-blue);
        }
        .assoc-suggestion-content .emoji {
            font-size: 2rem;
            display: block;
            margin-top: 0.5rem;
        }

        /* 6. Bias-Variance */
        .bv-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        .bv-btn {
            background-color: var(--item-bg, #4b5563);
            border: 2px solid var(--border-color);
            color: var(--text-light);
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            font-family: 'Noto Sans Arabic', 'Inter', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .bv-btn:hover { background-color: #525f73; }
        .bv-btn.active#btn-bv-underfit {
            border-color: var(--cluster-2);
            background-color: rgba(248, 113, 113, 0.1);
        }
        .bv-btn.active#btn-bv-goodfit {
            border-color: var(--cluster-1);
            background-color: rgba(52, 211, 153, 0.1);
        }
        .bv-btn.active#btn-bv-overfit {
            border-color: var(--cluster-3);
            background-color: rgba(251, 191, 36, 0.1);
        }
        .bv-model-line {
            fill: none;
            stroke-width: 4px;
            stroke-linecap: round;
            transition: d 0.3s ease-in-out, stroke 0.3s;
        }

        /* --- Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ© (Ù…ÙØ¯Ù…Ø¬Ø©) --- */
        .simulation-container > .simulation-controls.flex-wrap {
            display: flex;
            flex-wrap: wrap;
            justify-content: center; /* Adjusting for better alignment with other controls */
            gap: 0.75rem;
        }
        .control-card {
            background-color: var(--bg-dark);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            display: inline-block;
        }
        .control-card label, .control-card p {
             font-size: 0.875rem; /* text-sm equivalent */
             font-weight: 500;
             margin-bottom: 0.25rem;
             color: var(--text-light);
        }
        .control-card select {
            background-color: var(--item-bg); 
            padding: 0.5rem; 
            border-radius: 0.25rem; 
            width: 6rem;
            color: var(--text-light);
            border: 1px solid var(--border-color);
        }
        #status {
            color: var(--accent-blue); 
            font-weight: 700;
        }
        #lossValue span {
             color: var(--cluster-3); /* Yellow color for Loss value */
             font-weight: 700;
        }

        /* ØªØ®Ø·ÙŠØ· Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ©: Ø¹Ù…ÙˆØ¯ ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù„ØŒ ÙˆØ¹Ù…ÙˆØ¯Ø§Ù† Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„Ø£ÙƒØ¨Ø± */
        .grid-layout-nn {
            display: grid;
            grid-template-columns: 1fr; /* Ø¹Ù…ÙˆØ¯ ÙˆØ§Ø­Ø¯ Ø§ÙØªØ±Ø§Ø¶ÙŠÙ‹Ø§ */
            gap: 2rem;
            margin-top: 2rem;
        }
        /* Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„Ø£ÙƒØ¨Ø± (1024px ÙØ£ÙƒØ«Ø±)ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø¹Ù…ÙˆØ¯ÙŠÙ† */
        @media (min-width: 1024px) {
            .grid-layout-nn {
                grid-template-columns: 1fr 1fr; /* Ø¹Ù…ÙˆØ¯Ø§Ù† Ù…ØªØ³Ø§ÙˆÙŠØ§Ù† */
            }
        }

        .layer {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            position: relative;
            z-index: 10;
        }
        .neuron {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--accent-blue); 
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            border: 3px solid white;
            cursor: help;
            transition: background-color 0.3s, border-color 0.3s;
        }
        /* Color overrides for NN visualization */
        .input-neuron { background-color: var(--accent-blue); }
        .hidden-neuron { background-color: var(--cluster-1); }
        .output-neuron { background-color: var(--accent-blue); }

        /* Canvas Styles */
        #outputCanvas {
            border: 2px solid var(--border-color); 
            border-radius: 0.75rem; 
            margin-top: 1rem; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            width: 100%; /* Make it responsive within its column */
            max-width: 600px;
            height: auto;
            aspect-ratio: 600 / 400;
        }
        
    </style>
</head>
<body>
    <div class="dashboard-container">
        <header class="flex justify-between items-center mb-8">
            <a href="index.html" class="back-button">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                </svg>
                Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
            </a>
            <h1 class="text-3xl font-bold">Ù…ÙƒØªØ¨Ø© Ù…Ø­Ø§ÙƒØ§Ø© Ø¹Ù„Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</h1>
            <div class="w-6"></div> <!-- For balance --></header>
        
        <!-- Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙ†Ù‚Ù„ --><div class="tab-buttons">
            <button class="tab-btn active" data-tab="tab-kmeans">Ø§Ù„ØªØ¬Ù…ÙŠØ¹ (Clustering)</button>
            <button class="tab-btn" data-tab="tab-classification">Ø§Ù„ØªØµÙ†ÙŠÙ (Classification)</button>
            <button class="tab-btn" data-tab="tab-regression">Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø± (Regression)</button>
            <button class="tab-btn" data-tab="tab-dim-red">ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</button>
            <button class="tab-btn" data-tab="tab-assoc-rules">Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø·</button>
            <button class="tab-btn" data-tab="tab-bias-variance">Ù…Ø´ÙƒÙ„Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡</button>
            <button class="tab-btn" data-tab="tab-neural-network">Ø§Ù„Ø´Ø¨ÙƒØ§Øª Ø§Ù„Ø¹ØµØ¨ÙŠØ©</button>
        </div>
        
        <!-- Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù…Ø­ØªÙˆÙ‰ --><div class="tab-content">
            
            <!-- ======================= --><!-- 1. Ø§Ù„ØªØ¬Ù…ÙŠØ¹ (Clustering)  --><!-- ======================= --><div id="tab-kmeans" class="tab-pane active">
                <h2>Ø§Ù„ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù†Ù‚ÙˆØ¯ÙŠ (K-Means)</h2>
                <p>ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ØªØ´Ø§Ø¨Ù‡Ø© ÙÙŠ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª. Ø§Ø¶ØºØ· "Ø§Ø¨Ø¯Ø£" Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© ÙˆÙ‡ÙŠ ØªØ¹Ù…Ù„.</p>
                <div class="simulation-container">
                    <svg id="kmeans-svg" class="simulation-svg" viewBox="0 0 500 400"></svg>
                </div>
                <div class="simulation-controls">
                    <button id="btn-kmeans-start" class="sim-btn">Ø§Ø¨Ø¯Ø£ / Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©</button>
                    <button id="btn-kmeans-reset" class="sim-btn secondary">Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†</button>
                </div>
            </div>
            
            <!-- ========================= --><!-- 2. Ø§Ù„ØªØµÙ†ÙŠÙ (Classification) --><!-- ========================= --><div id="tab-classification" class="tab-pane">
                <h2>Ø§Ù„ØªØµÙ†ÙŠÙ (Classification)</h2>
                <p>Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨ÙØ¦Ø© (Categorical). Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© ØªÙˆØ¶Ø­ Ø±Ø³Ù… "Ø®Ø· ÙØ§ØµÙ„" Ø¨ÙŠÙ† ÙØ¦ØªÙŠÙ† Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.</p>
                <div class="simulation-container">
                    <svg id="class-svg" class="simulation-svg" viewBox="0 0 500 400"></svg>
                </div>
                <div class="simulation-controls">
                    <button id="btn-class-generate" class="sim-btn">ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©</button>
                </div>
            </div>

            <!-- ======================== --><!-- 3. Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø± (Regression) --><!-- ======================== --><div id="tab-regression" class="tab-pane">
                <h2>Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø± (Regression)</h2>
                <p>Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨Ù‚ÙŠÙ…Ø© Ø±Ù‚Ù…ÙŠØ© (Continuous). Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© ØªÙˆØ¶Ø­ "Ø®Ø· Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ø§Ù…" Ø§Ù„Ø°ÙŠ ÙŠÙ†Ø§Ø³Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.</p>
                <div class="simulation-container">
                    <svg id="reg-svg" class="simulation-svg" viewBox="0 0 500 400"></svg>
                </div>
                <div class="simulation-controls">
                    <button id="btn-reg-generate" class="sim-btn">ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©</button>
                </div>
            </div>

            <!-- ========================== --><!-- 4. ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (Dim Red) --><!-- ========================== --><div id="tab-dim-red" class="tab-pane">
                <h2>ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (Dimensionality Reduction)</h2>
                <p>ØªØ¨Ø³ÙŠØ· Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù† Ø·Ø±ÙŠÙ‚ "Ø¥Ø³Ù‚Ø§Ø·Ù‡Ø§" Ù…Ù† Ø£Ø¨Ø¹Ø§Ø¯ Ø£Ø¹Ù„Ù‰ Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ø£Ù‚Ù„ØŒ ÙƒÙ…Ø§ ÙŠØ¸Ù‡Ø± "Ø§Ù„Ø¸Ù„" Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø¯Ø§Ø±. Ù‡Ù†Ø§ØŒ Ù†Ø³Ù‚Ø· Ø¨ÙŠØ§Ù†Ø§Øª Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (3D) Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙŠØ§Øª Ø«Ù†Ø§Ø¦ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (2D).</p>
                <div class="simulation-controls">
                    <button id="btn-dimred-generate" class="sim-btn">ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©</button>
                </div>
                <div class="dim-red-layout">
                    <!-- Main 3D-like view -->
                    <div class="dim-red-box main-view">
                        <span class="dim-red-label">Ø¹Ø±Ø¶ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (Ù…Ø­Ø§ÙƒØ§Ø©)</span>
                        <svg id="dimred-svg-main" class="dim-red-svg"></svg>
                    </div>
                    <!-- XY Projection -->
                    <div class="dim-red-box">
                        <span class="dim-red-label">Ø¥Ø³Ù‚Ø§Ø· Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ X-Y</span>
                        <svg id="dimred-svg-xy" class="dim-red-svg"></svg>
                    </div>
                    <!-- YZ Projection -->
                    <div class="dim-red-box">
                        <span class="dim-red-label">Ø¥Ø³Ù‚Ø§Ø· Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Y-Z</span>
                        <svg id="dimred-svg-yz" class="dim-red-svg"></svg>
                    </div>
                     <!-- XZ Projection -->
                    <div class="dim-red-box">
                        <span class="dim-red-label">Ø¥Ø³Ù‚Ø§Ø· Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ X-Z</span>
                        <svg id="dimred-svg-xz" class="dim-red-svg"></svg>
                    </div>
                </div>
            </div>

            <!-- ============================= --><!-- 5. Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· (Assoc Rules) --><!-- ============================= --><div id="tab-assoc-rules" class="tab-pane">
                <h2>Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· (Association Rules)</h2>
                <p>Ø§ÙƒØªØ´Ù Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø®ÙÙŠØ©. Ø£Ø¶Ù Ù…Ù†ØªØ¬Ø§Øª Ù„Ù„Ø³Ù„Ø© ÙˆÙ„Ø§Ø­Ø¸ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª.</p>
                <div class="assoc-layout">
                    <div class="assoc-box">
                        <h3>Ø§Ù„Ù…ØªØ¬Ø±</h3>
                        <div class="assoc-item-buttons">
                            <button class="assoc-item-btn" data-item="ğŸ" data-id="bread" title="Ø®Ø¨Ø²">ğŸ</button>
                            <button class="assoc-item-btn" data-item="ğŸ¥›" data-id="milk" title="Ø­Ù„ÙŠØ¨">ğŸ¥›</button>
                            <button class="assoc-item-btn" data-item="ğŸ¥¨" data-id="chips" title="Ø´ÙŠØ¨Ø³">ğŸ¥¨</button>
                            <button class="assoc-item-btn" data-item="ğŸ¥¤" data-id="soda" title="Ù…Ø´Ø±ÙˆØ¨ ØºØ§Ø²ÙŠ">ğŸ¥¤</button>
                            <button class="assoc-item-btn" data-item="ğŸ¥š" data-id="eggs" title="Ø¨ÙŠØ¶">ğŸ¥š</button>
                            <button class="assoc-item-btn" data-item="ğŸ" data-id="apple" title="ØªÙØ§Ø­">ğŸ</button>
                        </div>
                    </div>
                    <div class="assoc-box">
                        <h3>Ø³Ù„Ø© Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª</h3>
                        <div id="assoc-cart-items"></div>
                        <button id="assoc-reset-btn" class="sim-btn danger" style="width: 100%;">Ø¥ÙØ±Ø§Øº Ø§Ù„Ø³Ù„Ø©</button>
                    </div>
                    <div class="assoc-box">
                        <h3>Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª (Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯)</h3>
                        <div id="assoc-suggestion-box">
                            <span>Ø£Ø¶Ù Ù…Ù†ØªØ¬Ø§Øª Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª...</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ============================= --><!-- 6. Ù…Ø´ÙƒÙ„Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡ (Bias/Variance) --><!-- ============================= --><div id="tab-bias-variance" class="tab-pane">
                <h2>Ù…Ø´ÙƒÙ„Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡ (Bias-Variance)</h2>
                <p>Ø§Ø®ØªØ± Ø¯Ø±Ø¬Ø© ØªØ¹Ù‚ÙŠØ¯ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ØŒ Ø«Ù… Ø¬Ø±Ù‘Ø¨ "ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©" Ù„ØªØ±Ù‰ Ø«Ø¨Ø§Øª Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ (Variance).</p>
                <div class="simulation-container">
                    <svg id="bv-svg" class="simulation-svg" viewBox="0 0 500 400"></svg>
                </div>
                <div class="bv-controls">
                    <button id="btn-bv-underfit" class="bv-btn">Ø¨Ø³ÙŠØ· (Underfitting)</button>
                    <button id="btn-bv-goodfit" class="bv-btn active">Ù…Ù„Ø§Ø¦Ù… (Good Fit)</button>
                    <button id="btn-bv-overfit" class="bv-btn">Ù…Ø¹Ù‚Ø¯ (Overfitting)</button>
                </div>
                <div class="simulation-controls">
                    <button id="btn-bv-new-data" class="sim-btn">ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©</button>
                </div>
            </div>
            
            <!-- ============================= --><!-- 7. Ø§Ù„Ø´Ø¨ÙƒØ§Øª Ø§Ù„Ø¹ØµØ¨ÙŠØ© (Neural Network) --><!-- ============================= --><div id="tab-neural-network" class="tab-pane">
                <h2>Ø´Ø¨ÙƒØ© Ø¹ØµØ¨ÙŠØ© Ø£Ù…Ø§Ù…ÙŠØ© (Feedforward)</h2>
                <p>Ø´Ø¨ÙƒØ© Ø¨Ø³ÙŠØ·Ø© Ù„ØªØµÙ†ÙŠÙ Ø§Ù„Ù†Ù‚Ø§Ø· Ø«Ù†Ø§Ø¦ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (X1, X2) Ø¥Ù„Ù‰ ÙØ¦ØªÙŠÙ† (Ø£Ø­Ù…Ø± ÙˆØ£Ø®Ø¶Ø±) Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø§Ù†ØªØ´Ø§Ø± Ø§Ù„Ø®Ù„ÙÙŠ.</p>
                <div class="simulation-container">
                     <!-- Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… -->
                    <div class="simulation-controls flex-wrap items-center justify-center gap-4 mb-8">
                        <div class="control-card">
                            <label for="learningRate" class="block text-sm font-medium mb-1">Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¹Ù„Ù… (Î±)</label>
                            <select id="learningRate" class="p-2 rounded w-24">
                                <option value="0.01">0.01</option>
                                <option value="0.05" selected>0.05</option>
                                <option value="0.1">0.1</option>
                            </select>
                        </div>
                        <div class="control-card">
                            <label for="hiddenNeurons" class="block text-sm font-medium mb-1">Ø¹Ù‚Ø¯ Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ø®ÙÙŠØ©</label>
                            <select id="hiddenNeurons" class="p-2 rounded w-24">
                                <option value="2">2</option>
                                <option value="3" selected>3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        <div class="control-card">
                            <p class="text-sm font-medium mb-1">Ø­Ø§Ù„Ø© Ø§Ù„ØªØ¯Ø±ÙŠØ¨:</p>
                            <div id="status" class="font-bold">Ù…ØªÙˆÙ‚Ù</div>
                        </div>
                        <div class="control-card">
                            <p class="text-sm font-medium mb-1">Ø§Ù„ØªÙƒØ±Ø§Ø± (Epoch):</p>
                            <div id="epochCount" class="font-bold">0</div>
                        </div>
                        <button id="btnStart" class="sim-btn">
                            Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¯Ø±ÙŠØ¨
                        </button>
                        <button id="btnReset" class="sim-btn secondary">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†</button>
                    </div>

                    <!-- Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø±Ø¦ÙŠØ© Ù„Ù„Ù…Ø­Ø§ÙƒØ§Ø© -->
                    <div class="grid-layout-nn">
                        <!-- Ø¹Ù…ÙˆØ¯ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ ÙˆØ§Ù„Ù†ØªØ§Ø¦Ø¬ -->
                        <div class="w-full mx-auto" style="max-width: 600px;">
                            <h3 style="font-size: 1.25rem; text-align: center;">Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ¯Ø±ÙŠØ¨ ÙˆØ§Ù„Ù†ØªØ§Ø¦Ø¬</h3>
                            <canvas id="outputCanvas" width="600" height="400" style="display: block; margin: 0 auto;"></canvas>
                            <div id="lossValue" class="mt-4 text-lg" style="text-align: center;">
                                Ø§Ù„Ø®Ø³Ø§Ø±Ø© (Loss): <span>---</span>
                            </div>
                            <div class="mt-2 text-sm" style="color: var(--text-muted); font-size: 0.875rem; text-align: center;">
                                <p>Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ù„ÙˆÙ†Ø©: Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©. ØªØ¯Ø±Ø¬ Ø§Ù„Ø®Ù„ÙÙŠØ©: ØªÙ†Ø¨Ø¤Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ©.</p>
                            </div>
                        </div>

                        <!-- Ø¹Ù…ÙˆØ¯ Ø§Ù„Ø´Ø¨ÙƒØ© -->
                        <div class="flex flex-col items-center w-full mx-auto" style="display: flex; flex-direction: column; align-items: center; max-width: 600px;">
                            <h3 style="font-size: 1.25rem;">Ø¨Ù†ÙŠØ© Ø§Ù„Ø´Ø¨ÙƒØ©</h3>
                            <div id="networkVizContainer" class="relative w-full h-96" style="position: relative; width: 100%; height: 24rem; display: flex; justify-content: center;">
                                <svg id="connection-svg" xmlns="http://www.w3.org/2000/svg" style="position: absolute; top: 0; right: 0; width: 100%; height: 100%; z-index: 5;"></svg>
                                <div class="flex justify-between items-center w-full h-full absolute top-0 right-0 p-4" style="display: flex; justify-content: space-around; align-items: center; width: 100%; height: 100%; position: absolute; top: 0; right: 0; padding: 1rem;">
                                    <div class="layer">
                                        <p class="text-center font-semibold mb-2" style="font-weight: 600; font-size: 1rem; color: var(--text-light); margin-bottom: 0.5rem;">Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„</p>
                                        <div class="neuron input-neuron" title="Ø§Ù„Ù…Ø¯Ø®Ù„ Ø§Ù„Ø£ÙˆÙ„ (X1)">X1</div>
                                        <div class="neuron input-neuron" title="Ø§Ù„Ù…Ø¯Ø®Ù„ Ø§Ù„Ø«Ø§Ù†ÙŠ (X2)">X2</div>
                                    </div>
                                    <div class="layer" id="hiddenLayerContainer">
                                        <!-- ØªÙÙ…Ù„Ø£ Ù‡Ù†Ø§ Ø§Ù„Ø¹Ù‚Ø¯ Ø§Ù„Ù…Ø®ÙÙŠØ© Ø¨ÙˆØ§Ø³Ø·Ø© JS -->
                                    </div>
                                    <div class="layer">
                                        <p class="text-center font-semibold mb-2" style="font-weight: 600; font-size: 1rem; color: var(--text-light); margin-bottom: 0.5rem;">Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬</p>
                                        <div class="neuron output-neuron">Y</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabPanes = document.querySelectorAll('.tab-pane');

            const simulations = {
                'tab-kmeans': { init: initKMeans, draw: () => window.runKMeansSimulation?.() },
                'tab-classification': { init: initClassification, draw: () => window.runClassificationSimulation?.() },
                'tab-regression': { init: initRegression, draw: () => window.runRegressionSimulation?.() },
                'tab-dim-red': { init: initDimRed, draw: () => setTimeout(() => window.runDimRedSimulation?.(), 50) },
                'tab-assoc-rules': { init: initAssocRules, draw: () => {} },
                'tab-bias-variance': { init: initBiasVariance, draw: () => window.runBiasVarianceSimulation?.() },
                'tab-neural-network': { init: initializeNN, draw: () => setTimeout(() => window.drawVisualization?.(), 50) }
            };
            const initializedTabs = new Set();

            function activateTab(tabId) {
                const activeTabButton = document.querySelector(`.tab-btn[data-tab="${tabId}"]`);
                const activePane = document.getElementById(tabId);
                if (!activeTabButton || !activePane) return;

                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabPanes.forEach(pane => pane.classList.remove('active'));

                activeTabButton.classList.add('active');
                activePane.classList.add('active');

                if (simulations[tabId]) {
                    if (!initializedTabs.has(tabId)) {
                        simulations[tabId].init();
                        initializedTabs.add(tabId);
                    } else if (simulations[tabId].draw) {
                        simulations[tabId].draw();
                    }
                }
            }

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.getAttribute('data-tab');
                    activateTab(tabId);
                });
            });

            function initKMeans() {
                const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
                const svg = document.getElementById('kmeans-svg');
                const startBtn = document.getElementById('btn-kmeans-start');
                const resetBtn = document.getElementById('btn-kmeans-reset');
                
                const svgWidth = 500, svgHeight = 400, padding = 50, k = 3;
                let points = [], centroids = [], clusters = [], step = 0; // 0: assign, 1: update
                
                const getColorForCluster = (idx) => ['#3b82f6', '#ef4444', '#10b981'][idx % 3];

                function draw() {
                    // =======================================================
                    // START: ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙƒÙ„Ø³ØªØ±Ù†Ø¬ (Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¸Ù„)
                    // 1. Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø¸Ù„ Ù„ÙƒÙ„ Ù…Ø¬Ù…ÙˆØ¹Ø© Ù‚Ø¨Ù„ Ø±Ø³Ù… Ø£ÙŠ Ø´ÙŠØ¡ Ø¢Ø®Ø±
                    // =======================================================
                    if (!svg) return;
                    svg.innerHTML = '';
                    points.forEach(point => {
                        const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
                        circle.setAttribute('cx', point.x);
                        circle.setAttribute('cy', point.y);
                        circle.setAttribute('r', 5);
                        circle.setAttribute('fill', centroids[point.cluster]?.color || '#9ca3af');
                        svg.appendChild(circle);
                    });
                    // Ø±Ø³Ù… Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø¸Ù„ (Voronoi-like areas)
                    centroids.forEach((centroid, idx) => {
                        const clusterPoints = points.filter(p => p.cluster === idx);
                        if (clusterPoints.length > 0) {
                            // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ù†ØµÙ Ù‚Ø·Ø± Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
                            const distances = clusterPoints.map(p => Math.hypot(p.x - centroid.x, p.y - centroid.y));
                            const avgRadius = distances.reduce((a, b) => a + b, 0) / distances.length;
                            const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
                            circle.setAttribute('cx', centroid.x);
                            circle.setAttribute('cy', centroid.y);
                            circle.setAttribute('r', avgRadius + 30); // Ù†ØµÙ Ù‚Ø·Ø± Ø§Ù„Ø¸Ù„ Ø£ÙƒØ¨Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹
                            circle.setAttribute('fill', centroid.color);
                            circle.setAttribute('class', 'cluster-area');
                            svg.insertBefore(circle, svg.firstChild); // Ø¥Ø¯Ø±Ø§Ø¬Ù‡ ÙÙŠ Ø§Ù„Ø®Ù„Ù
                        }
                    });
                    centroids.forEach((centroid) => {
                        const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
                        circle.setAttribute('cx', centroid.x);
                        circle.setAttribute('cy', centroid.y);
                        circle.setAttribute('r', 10);
                        circle.setAttribute('fill', centroid.color);
                        circle.setAttribute('class', 'centroid');
                        svg.appendChild(circle);
                    });
                    // =======================================================
                    // END: ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙƒÙ„Ø³ØªØ±Ù†Ø¬
                    // =======================================================
                }

                function assignPointsToClusters() {
                    clusters = Array(k).fill().map(() => []);
                    points.forEach(point => {
                        let minDist = Infinity, closestCentroidIdx = 0;
                        centroids.forEach((centroid, idx) => {
                            const dist = Math.hypot(point.x - centroid.x, point.y - centroid.y);
                            if (dist < minDist) { minDist = dist; closestCentroidIdx = idx; }
                        });
                        clusters[closestCentroidIdx].push(point);
                        point.cluster = closestCentroidIdx;
                    });
                }

                function updateCentroids() {
                    let hasMoved = false;
                    centroids.forEach((centroid, idx) => {
                        const clusterPoints = clusters[idx];
                        if (clusterPoints.length === 0) return;
                        const sum = clusterPoints.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
                        const newX = sum.x / clusterPoints.length;
                        const newY = sum.y / clusterPoints.length;
                        if (Math.hypot(newX - centroid.x, newY - centroid.y) > 1) hasMoved = true;
                        centroid.x = newX;
                        centroid.y = newY;
                    });
                    return hasMoved;
                }

                function nextStep() {
                    startBtn.disabled = true;
                    if (step === -1) { // If ended, restart
                        window.runKMeansSimulation();
                        return;
                    }

                    if (step === 0) { // Assign points
                        assignPointsToClusters();
                        startBtn.textContent = 'Ø§Ù„Ø®Ø·ÙˆØ© 2: ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø±Ø§ÙƒØ²';
                        step = 1;
                    } else { // Update centroids
                        const hasMoved = updateCentroids();
                        if (!hasMoved) {
                            startBtn.textContent = 'Ø§ÙƒØªÙ…Ù„! Ø§Ø¶ØºØ· Ù„Ù„Ø¥Ø¹Ø§Ø¯Ø©';
                            startBtn.disabled = false;
                            step = -1; // End state
                            draw();
                            return;
                        }
                        startBtn.textContent = 'Ø§Ù„Ø®Ø·ÙˆØ© 1: ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù†Ù‚Ø§Ø·';
                        step = 0;
                    }
                    draw();
                    startBtn.disabled = false;
                }
                
                window.runKMeansSimulation = function() {
                    step = 0;
                    startBtn.textContent = 'Ø§Ù„Ø®Ø·ÙˆØ© 1: ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù†Ù‚Ø§Ø·';
                    startBtn.disabled = false;
                    points = Array.from({ length: 50 }, () => ({
                        x: Math.random() * (svgWidth - 2 * padding) + padding,
                        y: Math.random() * (svgHeight - 2 * padding) + padding
                    }));
                    const usedIndices = new Set();
                    centroids = [];
                    while (centroids.length < k) {
                        const idx = Math.floor(Math.random() * points.length);
                        if (!usedIndices.has(idx)) {
                            usedIndices.add(idx);
                            centroids.push({ x: points[idx].x, y: points[idx].y, color: getColorForCluster(centroids.length) });
                        }
                    }
                    // Initial assignment before first draw
                    assignPointsToClusters();
                    draw();
                }
                
                startBtn.addEventListener('click', nextStep);
                resetBtn.addEventListener('click', window.runKMeansSimulation);
                
                window.runKMeansSimulation(); // Initial run
            }

            function initClassification() {
                const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
                const svg = document.getElementById('class-svg');
                const generateBtn = document.getElementById('btn-class-generate');
                const svgWidth = 500, svgHeight = 400, padding = 50;
                const CLASS_COLORS = { 0: '#ef4444', 1: '#10b981' };

                window.runClassificationSimulation = function() {
                    if (!svg) return;
                    svg.innerHTML = '';
                    const dataPoints = [];
                    for (let i = 0; i < 60; i++) {
                        const classId = i < 30 ? 0 : 1;
                        const baseX = classId === 0 ? svgWidth / 4 : (3 * svgWidth) / 4;
                        dataPoints.push({
                            x: baseX + (Math.random() - 0.5) * (svgWidth / 3),
                            y: svgHeight / 2 + (Math.random() - 0.5) * (svgHeight - 2 * padding),
                            class: classId
                        });
                    }

                    dataPoints.forEach(point => {
                        const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
                        circle.setAttribute('cx', point.x);
                        circle.setAttribute('cy', point.y);
                        circle.setAttribute('r', 8);
                        circle.style.fill = CLASS_COLORS[point.class];
                        svg.appendChild(circle);
                    });

                    const line = document.createElementNS(SVG_NAMESPACE, 'line');
                    line.setAttribute('x1', svgWidth / 2);
                    line.setAttribute('y1', 0);
                    line.setAttribute('x2', svgWidth / 2);
                    line.setAttribute('y2', svgHeight);
                    line.setAttribute('class', 'class-decision-boundary');
                    svg.appendChild(line);
                }
                generateBtn.addEventListener('click', window.runClassificationSimulation);
                window.runClassificationSimulation();
            }

            function initRegression() {
                const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
                const svg = document.getElementById('reg-svg');
                const generateBtn = document.getElementById('btn-reg-generate');
                const svgWidth = 500, svgHeight = 400, padding = 50;

                window.runRegressionSimulation = function() {
                    if (!svg) return;
                    svg.innerHTML = '';
                    const dataPoints = [];
                    const m_true = 0.6, b_true = svgHeight * 0.3;
                    for (let i = 0; i < 20; i++) {
                        const x = Math.random() * (svgWidth - 2 * padding) + padding;
                        dataPoints.push({ x: x, y: m_true * x + b_true + (Math.random() - 0.5) * 80 });
                    }

                    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                    dataPoints.forEach(p => { sumX += p.x; sumY += p.y; sumXY += p.x * p.y; sumX2 += p.x * p.x; });
                    const n = dataPoints.length;
                    const m = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                    const b = (sumY - m * sumX) / n;

                    const line = document.createElementNS(SVG_NAMESPACE, 'line');
                    line.setAttribute('x1', 0);
                    line.setAttribute('y1', b);
                    line.setAttribute('x2', svgWidth);
                    line.setAttribute('y2', m * svgWidth + b);
                    line.setAttribute('class', 'reg-line');
                    svg.appendChild(line);

                    dataPoints.forEach(point => {
                        const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
                        circle.setAttribute('cx', point.x);
                        circle.setAttribute('cy', point.y);
                        circle.setAttribute('r', 6);
                        circle.setAttribute('class', 'reg-point');
                        svg.appendChild(circle);
                    });
                }
                generateBtn.addEventListener('click', window.runRegressionSimulation);
                window.runRegressionSimulation();
            }

            function initDimRed() {
                const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
                const svgs = {
                    main: document.getElementById('dimred-svg-main'),
                    xy: document.getElementById('dimred-svg-xy'),
                    yz: document.getElementById('dimred-svg-yz'),
                    xz: document.getElementById('dimred-svg-xz')
                };
                const generateBtn = document.getElementById('btn-dimred-generate');
                let points3D = [], angle = 0, animationFrameId = null;

                function createSvgElement(tag, attrs) {
                    const el = document.createElementNS(SVG_NAMESPACE, tag);
                    for (let k in attrs) el.setAttribute(k, attrs[k]);
                    return el;
                }

                function generate3DData() {
                    // =======================================================
                    // START: ØªØ¹Ø¯ÙŠÙ„ ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø¬Ø¯ÙŠØ¯)
                    // 1. ØªØºÙŠÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„ØªÙƒÙˆÙ† Ø¹Ù„Ù‰ Ø´ÙƒÙ„ "Ù‚Ø±Øµ Ø¯Ø§Ø¦Ø±ÙŠ" Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ù…ÙƒØ¹Ø¨.
                    //    Ù‡Ø°Ø§ Ø§Ù„Ø´ÙƒÙ„ Ø³ÙŠØ¸Ù‡Ø± ÙƒØ¯Ø§Ø¦Ø±Ø© ÙÙŠ Ø¥Ø³Ù‚Ø§Ø· XYØŒ ÙˆÙƒØ®Ø· ÙÙŠ Ø¥Ø³Ù‚Ø§Ø· XZ Ùˆ YZ.
                    // =======================================================
                    points3D = [];
                    const numPoints = 200;
                    const radius = 1.2;
                    for (let i = 0; i < numPoints; i++) {
                        const angle = Math.random() * 2 * Math.PI;
                        const r = radius * Math.sqrt(Math.random()); // ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¨Ø´ÙƒÙ„ Ù…ØªØ³Ø§ÙˆÙ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©
                        points3D.push({
                            x: r * Math.cos(angle),
                            y: r * Math.sin(angle),
                            z: (Math.random() - 0.5) * 0.1 // Ø¬Ø¹Ù„ Ø§Ù„Ù‚Ø±Øµ Ù†Ø­ÙŠÙØ§Ù‹ Ø¬Ø¯Ø§Ù‹ Ø¹Ù„Ù‰ Ù…Ø­ÙˆØ± Z
                        });
                    }
                    // =======================================================
                    // END: ØªØ¹Ø¯ÙŠÙ„ ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
                    // =======================================================
                }

                function drawMainView() {
                    const svg = svgs.main;
                    if (!svg) return;
                    svg.innerHTML = '';
                    const { clientWidth: width, clientHeight: height } = svg;
                    if (width === 0 || height === 0) return;
                    const scale = Math.min(width, height) / 2.5, centerX = width / 2, centerY = height / 2;

                    const rotatedPoints = points3D.map(p => ({ ...p, rx: p.x * Math.cos(angle) - p.y * Math.sin(angle), ry: p.x * Math.sin(angle) + p.y * Math.cos(angle) }));
                    rotatedPoints.sort((a, b) => a.z - b.z).forEach(p => {
                        const projectedX = (p.rx - p.ry) * Math.cos(0.5);
                        const projectedY = ((p.rx + p.ry) / 2) - p.z * Math.sin(0.5);
                        const r = (p.z + 1.5) / 3 * 5 + 2;
                        const opacity = (p.z + 1.5) / 3 * 0.7 + 0.3;
                        svg.appendChild(createSvgElement('circle', { cx: centerX + projectedX * scale, cy: centerY - projectedY * scale, r, fill: 'var(--data-point-color)', opacity }));
                    });
                }

                function draw2DProjection(svg, dim1, dim2) {
                    if (!svg) return;
                    svg.innerHTML = '';
                    const { clientWidth: width, clientHeight: height } = svg;
                    if (width === 0 || height === 0) return;
                    const padding = 20, plotWidth = width - 2 * padding, plotHeight = height - 2 * padding;
                    points3D.forEach(p => {
                        const cx = padding + ((p[dim1] + 1.5) / 3) * plotWidth;
                        const cy = height - padding - ((p[dim2] + 1.5) / 3) * plotHeight;
                        svg.appendChild(createSvgElement('circle', { cx, cy, r: 4, fill: 'var(--data-point-color)', opacity: '0.7' }));
                    });
                }

                function animate() {
                    angle += 0.005;
                    drawMainView();
                    animationFrameId = requestAnimationFrame(animate);
                }

                window.runDimRedSimulation = function() {
                    generate3DData();
                    draw2DProjection(svgs.xy, 'x', 'y');
                    draw2DProjection(svgs.yz, 'y', 'z');
                    draw2DProjection(svgs.xz, 'x', 'z');
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    animate();
                }
                generateBtn.addEventListener('click', window.runDimRedSimulation);
                window.runDimRedSimulation();
            }

            function initAssocRules() {
                const cartItemsContainer = document.getElementById('assoc-cart-items');
                const suggestionBox = document.getElementById('assoc-suggestion-box');
                const resetBtn = document.getElementById('assoc-reset-btn');
                if (!cartItemsContainer || !suggestionBox || !resetBtn) return;

                let cart = new Set();
                const rules = { 'bread': 'milk', 'chips': 'soda' };
                const itemEmojis = { 'bread': 'ğŸ', 'milk': 'ğŸ¥›', 'chips': 'ğŸ¥¨', 'soda': 'ğŸ¥¤', 'eggs': 'ğŸ¥š', 'apple': 'ğŸ' };

                function updateView() {
                    cartItemsContainer.innerHTML = cart.size === 0 ? '' : Array.from(cart).map(item => `<span>${itemEmojis[item]}</span>`).join('');
                    let suggestionFound = false;
                    for (const [antecedent, consequent] of Object.entries(rules)) {
                        if (cart.has(antecedent) && !cart.has(consequent)) {
                            suggestionBox.classList.add('active');
                            suggestionBox.innerHTML = `<div class="assoc-suggestion-content">Ù„Ø£Ù†Ùƒ Ø§Ø´ØªØ±ÙŠØª ${itemEmojis[antecedent]}...<span class="emoji">${itemEmojis[consequent]}</span>Ù‚Ø¯ ØªØ±ØºØ¨ Ø£ÙŠØ¶Ø§Ù‹ ÙÙŠ Ø´Ø±Ø§Ø¡ ${itemEmojis[consequent]}!</div>`;
                            suggestionFound = true;
                            break;
                        }
                    }
                    if (!suggestionFound) {
                        suggestionBox.classList.remove('active');
                        suggestionBox.innerHTML = '<span>Ø£Ø¶Ù Ù…Ù†ØªØ¬Ø§Øª Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª...</span>';
                    }
                }

                document.querySelectorAll('.assoc-item-btn').forEach(button => button.addEventListener('click', () => {
                    cart.add(button.dataset.id);
                    updateView();
                }));
                resetBtn.addEventListener('click', () => {
                    cart.clear();
                    updateView();
                });
                updateView();
            }

            function initBiasVariance() {
                const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
                const svg = document.getElementById('bv-svg');
                const buttons = {
                    underfit: document.getElementById('btn-bv-underfit'),
                    goodfit: document.getElementById('btn-bv-goodfit'),
                    overfit: document.getElementById('btn-bv-overfit')
                };
                const btnNewData = document.getElementById('btn-bv-new-data');
                if (!svg || !btnNewData || !Object.values(buttons).every(b => b)) return;

                const svgWidth = 500, svgHeight = 400, padding = 50;
                let dataPoints = [], currentFit = 'goodfit';

                const trueFunction = x => Math.pow((x - svgWidth / 2) / (svgWidth / 3), 2) * (svgHeight / 4) + (svgHeight / 3);

                function generateDataPoints() {
                    dataPoints = Array.from({ length: 15 }, () => {
                        const x = Math.random() * (svgWidth - 2 * padding) + padding;
                        const y = trueFunction(x) + (Math.random() - 0.5) * (svgHeight / 6);
                        return { x, y: Math.max(padding, Math.min(svgHeight - padding, y)) };
                    });
                }

                function draw() {
                    svg.innerHTML = '';
                    dataPoints.forEach(p => {
                        const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
                        circle.setAttribute('cx', p.x);
                        circle.setAttribute('cy', p.y);
                        circle.setAttribute('r', 5);
                        circle.style.fill = 'var(--data-point-color)';
                        svg.appendChild(circle);
                    });

                    const path = document.createElementNS(SVG_NAMESPACE, 'path');
                    path.setAttribute('class', 'bv-model-line');
                    let d = '', color = '';

                    if (currentFit === 'underfit') {
                        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                        dataPoints.forEach(p => { sumX += p.x; sumY += p.y; sumXY += p.x * p.y; sumX2 += p.x * p.x; });
                        const n = dataPoints.length, m = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX), b = (sumY - m * sumX) / n;
                        d = `M 0 ${b} L ${svgWidth} ${m * svgWidth + b}`;
                        color = 'var(--cluster-2)';
                    } else if (currentFit === 'goodfit') {
                        d = `M ${padding} ${trueFunction(padding)}`;
                        for (let x = padding + 10; x <= svgWidth - padding; x += 10) d += ` L ${x} ${trueFunction(x)}`;
                        color = 'var(--cluster-1)';
                    } else { // overfit
                        const sorted = [...dataPoints].sort((a, b) => a.x - b.x);
                        d = `M${sorted[0].x},${sorted[0].y}`;
                        for (let i = 0; i < sorted.length - 1; i++) {
                            const p0 = sorted[i - 1] || sorted[i], p1 = sorted[i], p2 = sorted[i + 1], p3 = sorted[i + 2] || sorted[i + 1];
                            d += `C${p1.x + (p2.x - p0.x) / 6},${p1.y + (p2.y - p0.y) / 6},${p2.x - (p3.x - p1.x) / 6},${p2.y - (p3.y - p1.y) / 6},${p2.x},${p2.y}`;
                        }
                        color = 'var(--cluster-3)';
                    }
                    path.setAttribute('d', d);
                    path.setAttribute('stroke', color);
                    svg.appendChild(path);
                }

                window.runBiasVarianceSimulation = function() {
                    generateDataPoints();
                    draw();
                }

                Object.entries(buttons).forEach(([fit, btn]) => btn.addEventListener('click', () => {
                    currentFit = fit;
                    Object.values(buttons).forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    draw();
                }));
                btnNewData.addEventListener('click', window.runBiasVarianceSimulation);
                window.runBiasVarianceSimulation();
            }

            // =======================================================
            // START: Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ©
            // ØªÙ… Ù†Ù‚Ù„ ÙƒÙ„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø®Ø§Øµ Ø¨Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ© Ø¥Ù„Ù‰ Ø¯Ø§Ø®Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ù„Ø¶Ù…Ø§Ù† Ø¹Ù…Ù„Ù‡Ø§ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
            // =======================================================
            function initializeNN() {
                let isTraining = false, epoch = 0, network, data, canvas, ctx, animationFrameId;
                const CANVAS_WIDTH = 600, CANVAS_HEIGHT = 400;

                class NeuralNetwork {
                    // ... (ÙƒÙˆØ¯ Ø§Ù„ÙƒÙ„Ø§Ø³ ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ)
                    constructor(input, hidden, output) { this.inputNodes = input; this.hiddenNodes = hidden; this.outputNodes = output; this.weights_ih = Array(hidden).fill(0).map(() => Array(input).fill(0).map(() => Math.random() * 2 - 1)); this.weights_ho = Array(output).fill(0).map(() => Array(hidden).fill(0).map(() => Math.random() * 2 - 1)); this.bias_h = Array(hidden).fill(0).map(() => Math.random() * 2 - 1); this.bias_o = Array(output).fill(0).map(() => Math.random() * 2 - 1); } sigmoid = (x) => 1 / (1 + Math.exp(-x)); sigmoidDerivative = (y) => y * (1 - y); feedforward(inputArray) { const hidden_outputs = this.weights_ih.map((weights, i) => this.sigmoid(weights.reduce((acc, w, j) => acc + w * inputArray[j], 0) + this.bias_h[i])); const final_outputs = this.weights_ho.map((weights, i) => this.sigmoid(weights.reduce((acc, w, j) => acc + w * hidden_outputs[j], 0) + this.bias_o[i])); return { output: final_outputs, hidden_outputs }; } train(inputs, targets, lr) { const { output, hidden_outputs } = this.feedforward(inputs); const output_errors = targets.map((t, i) => t - output[i]); const output_gradients = output.map((o, i) => output_errors[i] * this.sigmoidDerivative(o) * lr); const hidden_errors = this.weights_ho[0].map((_, h) => output_errors[0] * this.weights_ho[0][h]); const hidden_gradients = hidden_outputs.map((h, i) => hidden_errors[i] * this.sigmoidDerivative(h) * lr); this.weights_ho[0] = this.weights_ho[0].map((w, j) => w + output_gradients[0] * hidden_outputs[j]); this.bias_o[0] += output_gradients[0]; this.weights_ih = this.weights_ih.map((w_row, i) => w_row.map((w, j) => w + hidden_gradients[i] * inputs[j])); this.bias_h = this.bias_h.map((b, i) => b + hidden_gradients[i]); }
                }

                function generateSpiralData() {
                    // ... (ÙƒÙˆØ¯ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ)
                    const points = [];
                    const numPointsPerClass = 50;
                    for (let i = 0; i < numPointsPerClass; i++) { const x = -1.5 + (Math.random() - 0.5) * 2; const y = 1 + (Math.random() - 0.5) * 2; points.push({ inputs: [x, y], target: 0 }); }
                    for (let i = 0; i < numPointsPerClass; i++) { const x = 1.5 + (Math.random() - 0.5) * 2; const y = -1 + (Math.random() - 0.5) * 2; points.push({ inputs: [x, y], target: 1 }); }
                    return points;
                }

                window.drawVisualization = function() {
                    // ... (ÙƒÙˆØ¯ Ø§Ù„Ø±Ø³Ù… ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ)
                    if (!network || !ctx || !data) return;
                    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    let totalLoss = 0;
                    const res = 20;
                    for (let i = 0; i < res; i++) { for (let j = 0; j < res; j++) { const x = (i / res) * 6 - 3, y = (j / res) * 4 - 2; const pred = network.feedforward([x, y]).output[0]; const alpha = Math.abs(pred - 0.5) * 2; ctx.fillStyle = pred < 0.5 ? `rgba(239, 68, 68, ${alpha * 0.4 + 0.1})` : `rgba(16, 185, 129, ${alpha * 0.4 + 0.1})`; ctx.fillRect((i / res) * CANVAS_WIDTH, CANVAS_HEIGHT - (j / res) * CANVAS_HEIGHT - (CANVAS_HEIGHT / res), CANVAS_WIDTH / res, CANVAS_HEIGHT / res); } }
                    data.forEach(p => { const px = (p.inputs[0] + 3) * (CANVAS_WIDTH / 6), py = CANVAS_HEIGHT - ((p.inputs[1] + 2) * (CANVAS_HEIGHT / 4)); ctx.beginPath(); ctx.arc(px, py, 5, 0, Math.PI * 2); ctx.fillStyle = p.target === 0 ? '#ef4444' : '#10b981'; ctx.fill(); ctx.strokeStyle = 'white'; ctx.lineWidth = 1.5; ctx.stroke(); totalLoss += Math.pow(p.target - network.feedforward(p.inputs).output[0], 2); });
                    document.getElementById('lossValue').querySelector('span').textContent = (totalLoss / data.length).toFixed(4);
                    updateNetworkDiagram();
                }

                function updateNetworkDiagram() {
                    // ... (ÙƒÙˆØ¯ Ø±Ø³Ù… Ù…Ø®Ø·Ø· Ø§Ù„Ø´Ø¨ÙƒØ© ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ)
                    const svg = document.getElementById('connection-svg');
                    if (!svg || !network) return;
                    svg.innerHTML = '';
                    const containerRect = svg.parentElement.getBoundingClientRect();
                    if (containerRect.width === 0) return;
                    const getPos = el => { const r = el.getBoundingClientRect(); return { x: r.left + r.width / 2 - containerRect.left, y: r.top + r.height / 2 - containerRect.top }; };
                    const inputs = Array.from(document.querySelectorAll('.input-neuron')), hiddens = Array.from(document.querySelectorAll('.hidden-neuron')), outputs = Array.from(document.querySelectorAll('.output-neuron'));
                    const drawConn = (s, t, w) => { const line = document.createElementNS("http://www.w3.org/2000/svg", 'line'); line.setAttribute('x1', s.x); line.setAttribute('y1', s.y); line.setAttribute('x2', t.x); line.setAttribute('y2', t.y); const weightAbs = Math.abs(w); line.setAttribute('stroke', w > 0 ? '#10b981' : '#ef4444'); line.setAttribute('stroke-width', 1 + weightAbs * 2); line.setAttribute('opacity', 0.5 + weightAbs * 0.3); svg.appendChild(line); };
                    hiddens.forEach((h, i) => { const hPos = getPos(h); inputs.forEach((inp, j) => drawConn(getPos(inp), hPos, network.weights_ih[i][j])); });
                    outputs.forEach((o, i) => { const oPos = getPos(o); hiddens.forEach((h, j) => drawConn(getPos(h), oPos, network.weights_ho[i][j])); });
                }

                function trainLoop() {
                    // ... (ÙƒÙˆØ¯ Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ¯Ø±ÙŠØ¨ ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ)
                    if (!isTraining) return;
                    if (epoch >= 8) { // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 8 epochs
                        isTraining = false; // Ø£ÙˆÙ‚Ù Ø§Ù„ØªØ¯Ø±ÙŠØ¨
                        document.getElementById('status').textContent = 'Ø§ÙƒØªÙ…Ù„ Ø§Ù„ØªØ¯Ø±ÙŠØ¨'; // Ø­Ø¯Ø« Ø§Ù„Ø­Ø§Ù„Ø©
                        document.getElementById('btnStart').innerHTML = 'Ø§ÙƒØªÙ…Ù„'; // ØºÙŠØ± Ù†Øµ Ø§Ù„Ø²Ø±
                        document.getElementById('btnStart').disabled = true; // Ø¹Ø·Ù„ Ø§Ù„Ø²Ø±
                        return;
                    }
                    const lr = parseFloat(document.getElementById('learningRate').value);
                    for(let i = 0; i < 100; i++) { 
                        data.forEach(p => network.train(p.inputs, [p.target], lr));
                    }
                    epoch += 1; // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù€ epoch Ø¨Ù…Ù‚Ø¯Ø§Ø± 1 ÙÙŠ ÙƒÙ„ Ø¯ÙˆØ±Ø©
                    document.getElementById('epochCount').textContent = epoch;
                    window.drawVisualization();
                    animationFrameId = requestAnimationFrame(trainLoop); // Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø§Ù„Ø­Ù„Ù‚Ø©
                }

                function resetNetwork() {
                    // ... (ÙƒÙˆØ¯ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ† ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ)
                    isTraining = false;
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    epoch = 0;
                    const hiddenCount = parseInt(document.getElementById('hiddenNeurons').value);
                    const hiddenLayerContainer = document.getElementById('hiddenLayerContainer');
                    hiddenLayerContainer.innerHTML = `<p class="text-center font-semibold mb-2">Ù…Ø®ÙÙŠØ© (${hiddenCount})</p>` + Array.from({ length: hiddenCount }, (_, i) => `<div class="neuron hidden-neuron">H${i + 1}</div>`).join('');
                    network = new NeuralNetwork(2, hiddenCount, 1);
                    data = generateSpiralData();
                    document.getElementById('epochCount').textContent = 0;
                    document.getElementById('status').textContent = 'Ù…ØªÙˆÙ‚Ù';
                    document.getElementById('btnStart').innerHTML = 'Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¯Ø±ÙŠØ¨';
                    document.getElementById('btnStart').disabled = false; // Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø²Ø±
                    setTimeout(window.drawVisualization, 50);
                }

                const btnStart = document.getElementById('btnStart');
                btnStart.addEventListener('click', () => {
                    isTraining = !isTraining;
                    btnStart.innerHTML = isTraining ? 'Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª' : 'Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„ØªØ¯Ø±ÙŠØ¨';
                    document.getElementById('status').textContent = isTraining ? 'ÙŠØªØ¯Ø±Ø¨...' : 'Ù…ØªÙˆÙ‚Ù Ù…Ø¤Ù‚ØªÙ‹Ø§';
                    if (isTraining) trainLoop();
                });
                document.getElementById('btnReset').addEventListener('click', resetNetwork);
                document.getElementById('learningRate').addEventListener('change', resetNetwork);
                document.getElementById('hiddenNeurons').addEventListener('change', resetNetwork);
                
                canvas = document.getElementById('outputCanvas');
                if (canvas) {
                    ctx = canvas.getContext('2d');
                    resetNetwork();
                }
            }
            // =======================================================
            // END: Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ©
            // =======================================================

            const initialActiveTabId = document.querySelector('.tab-btn.active')?.getAttribute('data-tab') || 'tab-kmeans';
            activateTab(initialActiveTabId);
        });
    </script>
</body>
</html>