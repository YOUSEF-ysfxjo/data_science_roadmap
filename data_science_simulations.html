<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…ÙƒØªØ¨Ø© Ù…Ø­Ø§ÙƒØ§Ø© Ø¹Ù„Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</title>
    
    <!-- Ø¬Ù„Ø¨ Ø§Ù„Ø®Ø·ÙˆØ· --><link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+Arabic:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø«ÙŠÙ… Ø§Ù„Ù…ÙˆØ­Ø¯ */
            --bg-dark: #2a303c;
            --card-dark: #364152;
            --text-light: #e5e7eb;
            --text-muted: #9ca3af;
            --border-color: #4b5563;
            --accent-blue: #3b82f6; /* Ù„ÙˆÙ† Ø±Ø¦ÙŠØ³ÙŠ */
            
            /* Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª */
            --cluster-1: #34D399; /* Ø£Ø®Ø¶Ø± (Ù„Ù„ÙØ¦Ø© 1 ÙˆÙ„Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¬ÙŠØ¯) */
            --cluster-2: #F87171; /* Ø£Ø­Ù…Ø± (Ù„Ù„ÙØ¦Ø© 0 ÙˆÙ„Ù„ØªØ­ÙŠØ² Ø§Ù„Ø¹Ø§Ù„ÙŠ) */
            --cluster-3: #FBBF24; /* Ø£ØµÙØ± (Ù„ØªØ¨Ø§ÙŠÙ† Ø§Ù„Ø¹Ø§Ù„ÙŠ) */
            --data-point-color: #60a5fa; /* Ø£Ø²Ø±Ù‚ */
            --item-bg: #4b5563; /* Ù„ÙˆÙ† Ø®Ù„ÙÙŠØ© Ø§Ù„Ø¹Ù†Ø§ØµØ± */
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-light);
            font-family: 'Tajawal', 'Noto Sans Arabic', 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 2rem;
            box-sizing: border-box;
            line-height: 1.8;
            font-size: 1.1rem;
        }

        .back-button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-blue);
            text-decoration: none;
            font-weight: 600;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
        }

        .back-button:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }

        .back-button svg {
            width: 1.25rem;
            height: 1.25rem;
        }

        .dashboard-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 1rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        h1 {
            font-size: 2.25rem;
            font-weight: 700;
            margin-top: 0;
            margin-bottom: 1.5rem;
            text-align: center;
        }
        
        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 0.5rem;
            color: var(--text-light);
        }
        
        h3 {
             font-size: 1.25rem;
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        p {
            color: var(--text-muted);
            margin-bottom: 1.5rem;
            font-size: 1rem;
            line-height: 1.6;
        }

        /* --- Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ†Ù‚Ù„ (Tabs) --- */
        .tab-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 2rem;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 1rem;
        }
        
        .tab-btn {
            background-color: var(--item-bg, #4b5563);
            border: 1px solid var(--border-color);
            color: var(--text-light);
            border-radius: 0.5rem;
            padding: 0.6rem 1rem;
            font-size: 0.875rem;
            font-family: 'Noto Sans Arabic', 'Inter', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        
        .tab-btn:hover {
            background-color: #525f73;
        }
        
        .tab-btn.active {
            background-color: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        /* Ø­Ø§ÙˆÙŠØ§Øª Ø§Ù„Ù…Ø­ØªÙˆÙ‰ */
        .tab-content {
            border-radius: 0.5rem;
        }
        
        .tab-pane {
            display: none;
            animation: fadeIn 0.5s;
        }
        
        .tab-pane.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* --- Ø£Ù†Ù…Ø§Ø· Ø¹Ø§Ù…Ø© Ù„Ù„Ù…Ø­Ø§ÙƒØ§Ø© --- */
        .simulation-container {
            background-color: var(--card-dark);
            border-radius: 1rem;
            padding: 2rem;
            margin: 2rem 0;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            min-height: 500px;
            display: flex;
            flex-direction: column;
        }

        .simulation-svg {
            width: 100%;
            height: 400px;
            display: block;
        }
        
        .simulation-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        
        .sim-btn {
            background-color: var(--accent-blue);
            color: white;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1rem;
            font-family: 'Noto Sans Arabic', 'Inter', sans-serif;
            transition: background-color 0.2s;
        }
        .sim-btn:hover {
            background-color: #2563eb;
        }
        .sim-btn.secondary {
            background-color: var(--item-bg, #4b5563);
        }
        .sim-btn.secondary:hover {
             background-color: #525f73;
        }
         .sim-btn.danger {
            background-color: #dc2626; /* Ø£Ø­Ù…Ø± */
        }
        .sim-btn.danger:hover {
            background-color: #b91c1c;
        }
        
        .sim-btn:disabled {
            background-color: #4b5563;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        /* --- Ø£Ù†Ù…Ø§Ø· Ø®Ø§ØµØ© Ù„ÙƒÙ„ Ù…Ø­Ø§ÙƒØ§Ø© (Ù…ÙÙ„Ø®ØµØ©) --- */

        /* 1. K-Means */
        .centroid {
            stroke-width: 4px;
            stroke: white;
            opacity: 0.8;
        }
        .cluster-area {
            opacity: 0.2;
        }

        /* 2. Classification */
        .class-decision-boundary {
            stroke: var(--accent-blue);
            stroke-width: 4px;
            stroke-dasharray: 8 8;
        }

        /* 3. Regression */
        .reg-line {
            stroke: var(--accent-blue);
            stroke-width: 4px;
        }
        .reg-point {
            fill: var(--data-point-color);
        }

        /* 4. Dimensionality Reduction */
        .dim-red-layout {
            display: grid;
            grid-template-columns: 1.5fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 1rem;
        }
        .dim-red-box {
            background-color: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem;
            position: relative;
        }
        .dim-red-box.main-view {
            grid-row: span 2;
        }
        .dim-red-svg {
            width: 100%;
            height: 100%;
            min-height: 150px;
        }
        .dim-red-box .dim-red-label {
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 0.8rem;
            color: var(--text-muted);
            font-weight: 600;
        }

        /* 5. Association Rules */
        .assoc-layout {
            display: grid;
            gap: 1.5rem;
        }
        .assoc-box {
            background-color: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem;
        }
        .assoc-item-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
        }
        .assoc-item-btn {
            background-color: var(--item-bg, #4b5563);
            border: 1px solid var(--border-color);
            color: var(--text-light);
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            font-size: 1.5rem;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }
        .assoc-item-btn:hover { background-color: #525f73; }
        .assoc-item-btn:active { transform: scale(0.95); }
        
        #assoc-cart-items {
            font-size: 2.5rem;
            min-height: 50px;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.5rem;
            background-color: var(--card-dark);
            margin-bottom: 1rem;
        }
        #assoc-suggestion-box {
            min-height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1rem;
            color: var(--text-muted);
            border-radius: 0.5rem;
            background-color: var(--card-dark);
            padding: 1rem;
            text-align: center;
            transition: background-color 0.3s, border-color 0.3s;
        }
        #assoc-suggestion-box.active {
            color: var(--text-light);
            background-color: #2a4a7d;
            border: 1px solid var(--accent-blue);
        }
        .assoc-suggestion-content .emoji {
            font-size: 2rem;
            display: block;
            margin-top: 0.5rem;
        }

        /* 6. Bias-Variance */
        .bv-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        .bv-btn {
            background-color: var(--item-bg, #4b5563);
            border: 2px solid var(--border-color);
            color: var(--text-light);
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            font-family: 'Noto Sans Arabic', 'Inter', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .bv-btn:hover { background-color: #525f73; }
        .bv-btn.active#btn-bv-underfit {
            border-color: var(--cluster-2);
            background-color: rgba(248, 113, 113, 0.1);
        }
        .bv-btn.active#btn-bv-goodfit {
            border-color: var(--cluster-1);
            background-color: rgba(52, 211, 153, 0.1);
        }
        .bv-btn.active#btn-bv-overfit {
            border-color: var(--cluster-3);
            background-color: rgba(251, 191, 36, 0.1);
        }
        .bv-model-line {
            fill: none;
            stroke-width: 4px;
            stroke-linecap: round;
            transition: d 0.3s ease-in-out, stroke 0.3s;
        }

        /* --- Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ© (Ù…ÙØ¯Ù…Ø¬Ø©) --- */
        .simulation-container > .simulation-controls.flex-wrap {
            display: flex;
            flex-wrap: wrap;
            justify-content: center; /* Adjusting for better alignment with other controls */
            gap: 0.75rem;
        }
        .control-card {
            background-color: var(--bg-dark);
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            display: inline-block;
        }
        .control-card label, .control-card p {
             font-size: 0.875rem; /* text-sm equivalent */
             font-weight: 500;
             margin-bottom: 0.25rem;
             color: var(--text-light);
        }
        .control-card select {
            background-color: var(--item-bg); 
            padding: 0.5rem; 
            border-radius: 0.25rem; 
            width: 6rem;
            color: var(--text-light);
            border: 1px solid var(--border-color);
        }
        #status {
            color: var(--accent-blue); 
            font-weight: 700;
        }
        #lossValue span {
             color: var(--cluster-3); /* Yellow color for Loss value */
             font-weight: 700;
        }

        /* ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªØ®Ø·ÙŠØ· Ù„ÙŠÙƒÙˆÙ† Ø¹Ù…ÙˆØ¯Ø§Ù‹ ÙˆØ§Ø­Ø¯Ø§Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© Ø«Ù… ØµÙÙŠÙ† (ØªØ­Øª Ø¨Ø¹Ø¶) Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ÙƒØ¨ÙŠØ±Ø© */
        .grid-layout-nn {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            margin-top: 2rem;
        }
        /* Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„Ø£ÙƒØ¨Ø± (Ù…ØªÙˆØ³Ø· ÙˆÙ…Ø§ ÙÙˆÙ‚) */
        @media (min-width: 768px) {
            .grid-layout-nn {
                display: grid; 
                grid-template-columns: 1fr; /* Ø¹Ù…ÙˆØ¯ ÙˆØ§Ø­Ø¯ */
            }
        }

        .layer {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            position: relative;
            z-index: 10;
        }
        .neuron {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--accent-blue); 
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            border: 3px solid white;
            cursor: help;
            transition: background-color 0.3s, border-color 0.3s;
        }
        /* Color overrides for NN visualization */
        .input-neuron { background-color: var(--accent-blue); }
        .hidden-neuron { background-color: var(--cluster-1); }
        .output-neuron { background-color: var(--accent-blue); }

        /* Canvas Styles */
        #outputCanvas {
            border: 2px solid var(--border-color); 
            border-radius: 0.75rem; 
            margin-top: 1rem; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            width: 100%; /* Make it responsive within its column */
            max-width: 600px;
            height: auto;
            aspect-ratio: 600 / 400;
        }
        
    </style>
</head>
<body>
    <div class="dashboard-container">
        <header class="flex justify-between items-center mb-8">
            <a href="index.html" class="back-button">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                </svg>
                Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
            </a>
            <h1 class="text-3xl font-bold">Ù…ÙƒØªØ¨Ø© Ù…Ø­Ø§ÙƒØ§Ø© Ø¹Ù„Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</h1>
            <div class="w-6"></div> <!-- For balance --></header>
        
        <!-- Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙ†Ù‚Ù„ --><div class="tab-buttons">
            <button class="tab-btn active" data-tab="tab-kmeans">Ø§Ù„ØªØ¬Ù…ÙŠØ¹ (Clustering)</button>
            <button class="tab-btn" data-tab="tab-classification">Ø§Ù„ØªØµÙ†ÙŠÙ (Classification)</button>
            <button class="tab-btn" data-tab="tab-regression">Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø± (Regression)</button>
            <button class="tab-btn" data-tab="tab-dim-red">ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</button>
            <button class="tab-btn" data-tab="tab-assoc-rules">Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø·</button>
            <button class="tab-btn" data-tab="tab-bias-variance">Ù…Ø´ÙƒÙ„Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡</button>
            <button class="tab-btn" data-tab="tab-neural-network">Ø§Ù„Ø´Ø¨ÙƒØ§Øª Ø§Ù„Ø¹ØµØ¨ÙŠØ©</button>
        </div>
        
        <!-- Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù…Ø­ØªÙˆÙ‰ --><div class="tab-content">
            
            <!-- ======================= --><!-- 1. Ø§Ù„ØªØ¬Ù…ÙŠØ¹ (Clustering)  --><!-- ======================= --><div id="tab-kmeans" class="tab-pane active">
                <h2>Ø§Ù„ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù†Ù‚ÙˆØ¯ÙŠ (K-Means)</h2>
                <p>ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ØªØ´Ø§Ø¨Ù‡Ø© ÙÙŠ Ù…Ø¬Ù…ÙˆØ¹Ø§Øª. Ø§Ø¶ØºØ· "Ø§Ø¨Ø¯Ø£" Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© ÙˆÙ‡ÙŠ ØªØ¹Ù…Ù„.</p>
                <div class="simulation-container">
                    <svg id="kmeans-svg" class="simulation-svg" viewBox="0 0 500 400"></svg>
                </div>
                <div class="simulation-controls">
                    <button id="btn-kmeans-start" class="sim-btn">Ø§Ø¨Ø¯Ø£ / Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©</button>
                    <button id="btn-kmeans-reset" class="sim-btn secondary">Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†</button>
                </div>
            </div>
            
            <!-- ========================= --><!-- 2. Ø§Ù„ØªØµÙ†ÙŠÙ (Classification) --><!-- ========================= --><div id="tab-classification" class="tab-pane">
                <h2>Ø§Ù„ØªØµÙ†ÙŠÙ (Classification)</h2>
                <p>Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨ÙØ¦Ø© (Categorical). Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© ØªÙˆØ¶Ø­ Ø±Ø³Ù… "Ø®Ø· ÙØ§ØµÙ„" Ø¨ÙŠÙ† ÙØ¦ØªÙŠÙ† Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.</p>
                <div class="simulation-container">
                    <svg id="class-svg" class="simulation-svg" viewBox="0 0 500 400"></svg>
                </div>
                <div class="simulation-controls">
                    <button id="btn-class-generate" class="sim-btn">ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©</button>
                </div>
            </div>

            <!-- ======================== --><!-- 3. Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø± (Regression) --><!-- ======================== --><div id="tab-regression" class="tab-pane">
                <h2>Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø± (Regression)</h2>
                <p>Ø§Ù„ØªÙ†Ø¨Ø¤ Ø¨Ù‚ÙŠÙ…Ø© Ø±Ù‚Ù…ÙŠØ© (Continuous). Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© ØªÙˆØ¶Ø­ "Ø®Ø· Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ø§Ù…" Ø§Ù„Ø°ÙŠ ÙŠÙ†Ø§Ø³Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.</p>
                <div class="simulation-container">
                    <svg id="reg-svg" class="simulation-svg" viewBox="0 0 500 400"></svg>
                </div>
                <div class="simulation-controls">
                    <button id="btn-reg-generate" class="sim-btn">ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©</button>
                </div>
            </div>

            <!-- ========================== --><!-- 4. ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (Dim Red) --><!-- ========================== --><div id="tab-dim-red" class="tab-pane">
                <h2>ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (Dimensionality Reduction)</h2>
                <p>ØªØ¨Ø³ÙŠØ· Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù† Ø·Ø±ÙŠÙ‚ "Ø¥Ø³Ù‚Ø§Ø·Ù‡Ø§" Ù…Ù† Ø£Ø¨Ø¹Ø§Ø¯ Ø£Ø¹Ù„Ù‰ Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ø£Ù‚Ù„ØŒ ÙƒÙ…Ø§ ÙŠØ¸Ù‡Ø± "Ø§Ù„Ø¸Ù„" Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø¯Ø§Ø±.</p>
                <div class="dim-red-layout" style="grid-template-columns: 1fr 1fr;">
                    <!-- Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (3D) --><div class="dim-red-box main-view" style="grid-row: auto;">
                        <span class="dim-red-label">Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£ØµÙ„ÙŠØ© (3D)</span>
                        <svg id="dimred-svg-main" class="dim-red-svg"></svg>
                    </div>
                    <!-- Ø§Ù„Ø¥Ø³Ù‚Ø§Ø· Ø§Ù„Ø£ÙˆÙ„ (X-Y) --><div class="dim-red-box">
                        <span class="dim-red-label">Ø§Ù„Ø¥Ø³Ù‚Ø§Ø· (X-Y)</span>
                        <svg id="dimred-svg-xy" class="dim-red-svg"></svg>
                    </div>
                    <!-- Ø§Ù„Ø¥Ø³Ù‚Ø§Ø· Ø§Ù„Ø«Ø§Ù†ÙŠ (Y-Z) --><div class="dim-red-box">
                        <span class="dim-red-label">Ø§Ù„Ø¥Ø³Ù‚Ø§Ø· (Y-Z)</span>
                        <svg id="dimred-svg-yz" class="dim-red-svg"></svg>
                    </div>
                </div>
            </div>

            <!-- ============================= --><!-- 5. Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· (Assoc Rules) --><!-- ============================= --><div id="tab-assoc-rules" class="tab-pane">
                <h2>Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· (Association Rules)</h2>
                <p>Ø§ÙƒØªØ´Ù Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø®ÙÙŠØ©. Ø£Ø¶Ù Ù…Ù†ØªØ¬Ø§Øª Ù„Ù„Ø³Ù„Ø© ÙˆÙ„Ø§Ø­Ø¸ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª.</p>
                <div class="assoc-layout">
                    <div class="assoc-box">
                        <h3>Ø§Ù„Ù…ØªØ¬Ø±</h3>
                        <div class="assoc-item-buttons">
                            <button class="assoc-item-btn" data-item="ğŸ" data-id="bread" title="Ø®Ø¨Ø²">ğŸ</button>
                            <button class="assoc-item-btn" data-item="ğŸ¥›" data-id="milk" title="Ø­Ù„ÙŠØ¨">ğŸ¥›</button>
                            <button class="assoc-item-btn" data-item="ğŸ¥¨" data-id="chips" title="Ø´ÙŠØ¨Ø³">ğŸ¥¨</button>
                            <button class="assoc-item-btn" data-item="ğŸ¥¤" data-id="soda" title="Ù…Ø´Ø±ÙˆØ¨ ØºØ§Ø²ÙŠ">ğŸ¥¤</button>
                            <button class="assoc-item-btn" data-item="ğŸ¥š" data-id="eggs" title="Ø¨ÙŠØ¶">ğŸ¥š</button>
                            <button class="assoc-item-btn" data-item="ğŸ" data-id="apple" title="ØªÙØ§Ø­">ğŸ</button>
                        </div>
                    </div>
                    <div class="assoc-box">
                        <h3>Ø³Ù„Ø© Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª</h3>
                        <div id="assoc-cart-items"></div>
                        <button id="assoc-reset-btn" class="sim-btn danger" style="width: 100%;">Ø¥ÙØ±Ø§Øº Ø§Ù„Ø³Ù„Ø©</button>
                    </div>
                    <div class="assoc-box">
                        <h3>Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª (Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯)</h3>
                        <div id="assoc-suggestion-box">
                            <span>Ø£Ø¶Ù Ù…Ù†ØªØ¬Ø§Øª Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª...</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ============================= --><!-- 6. Ù…Ø´ÙƒÙ„Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡ (Bias/Variance) --><!-- ============================= --><div id="tab-bias-variance" class="tab-pane">
                <h2>Ù…Ø´ÙƒÙ„Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡ (Bias-Variance)</h2>
                <p>Ø§Ø®ØªØ± Ø¯Ø±Ø¬Ø© ØªØ¹Ù‚ÙŠØ¯ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ØŒ Ø«Ù… Ø¬Ø±Ù‘Ø¨ "ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©" Ù„ØªØ±Ù‰ Ø«Ø¨Ø§Øª Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ (Variance).</p>
                <div class="simulation-container">
                    <svg id="bv-svg" class="simulation-svg" viewBox="0 0 500 400"></svg>
                </div>
                <div class="bv-controls">
                    <button id="btn-bv-underfit" class="bv-btn">Ø¨Ø³ÙŠØ· (Underfitting)</button>
                    <button id="btn-bv-goodfit" class="bv-btn active">Ù…Ù„Ø§Ø¦Ù… (Good Fit)</button>
                    <button id="btn-bv-overfit" class="bv-btn">Ù…Ø¹Ù‚Ø¯ (Overfitting)</button>
                </div>
                <div class="simulation-controls">
                    <button id="btn-bv-new-data" class="sim-btn">ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©</button>
                </div>
            </div>
            
            <!-- ============================= --><!-- 7. Ø§Ù„Ø´Ø¨ÙƒØ§Øª Ø§Ù„Ø¹ØµØ¨ÙŠØ© (Neural Network) --><!-- ============================= --><div id="tab-neural-network" class="tab-pane">
                <h2>Ø´Ø¨ÙƒØ© Ø¹ØµØ¨ÙŠØ© Ø£Ù…Ø§Ù…ÙŠØ© (Feedforward)</h2>
                <p>Ø´Ø¨ÙƒØ© Ø¨Ø³ÙŠØ·Ø© Ù„ØªØµÙ†ÙŠÙ Ø§Ù„Ù†Ù‚Ø§Ø· Ø«Ù†Ø§Ø¦ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (X1, X2) Ø¥Ù„Ù‰ ÙØ¦ØªÙŠÙ† (Ø£Ø­Ù…Ø± ÙˆØ£Ø®Ø¶Ø±) Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø§Ù†ØªØ´Ø§Ø± Ø§Ù„Ø®Ù„ÙÙŠ.</p>
                <div class="simulation-container">
                     <!-- Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… -->
                    <div class="simulation-controls flex-wrap items-center justify-center gap-4 mb-8">
                        <div class="control-card">
                            <label for="learningRate" class="block text-sm font-medium mb-1">Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¹Ù„Ù… (Î±)</label>
                            <select id="learningRate" class="p-2 rounded w-24">
                                <option value="0.01">0.01</option>
                                <option value="0.05" selected>0.05</option>
                                <option value="0.1">0.1</option>
                            </select>
                        </div>
                        <div class="control-card">
                            <label for="hiddenNeurons" class="block text-sm font-medium mb-1">Ø¹Ù‚Ø¯ Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ø®ÙÙŠØ©</label>
                            <select id="hiddenNeurons" class="p-2 rounded w-24">
                                <option value="2">2</option>
                                <option value="3" selected>3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        <div class="control-card">
                            <p class="text-sm font-medium mb-1">Ø­Ø§Ù„Ø© Ø§Ù„ØªØ¯Ø±ÙŠØ¨:</p>
                            <div id="status" class="font-bold">Ù…ØªÙˆÙ‚Ù</div>
                        </div>
                        <div class="control-card">
                            <p class="text-sm font-medium mb-1">Ø§Ù„ØªÙƒØ±Ø§Ø± (Epoch):</p>
                            <div id="epochCount" class="font-bold">0</div>
                        </div>
                        <button id="btnStart" class="sim-btn">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ml-2" viewBox="0 0 20 20" fill="currentColor" style="width: 1.25rem; height: 1.25rem; margin-left: 0.5rem; display: inline-block;">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                            </svg>
                            Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¯Ø±ÙŠØ¨
                        </button>
                        <button id="btnReset" class="sim-btn secondary">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†</button>
                    </div>

                    <!-- Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø±Ø¦ÙŠØ© Ù„Ù„Ù…Ø­Ø§ÙƒØ§Ø© -->
                    <div class="grid-layout-nn">
                        <!-- Ø¹Ù…ÙˆØ¯ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ ÙˆØ§Ù„Ù†ØªØ§Ø¦Ø¬ (Ø§Ù„Ø¢Ù† ÙŠØµØ¨Ø­ Ø§Ù„ØµÙ Ø§Ù„Ø£ÙˆÙ„) -->
                        <div class="w-full mx-auto" style="max-width: 600px;">
                            <h3 style="font-size: 1.25rem; text-align: center;">Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ¯Ø±ÙŠØ¨ ÙˆØ§Ù„Ù†ØªØ§Ø¦Ø¬</h3>
                            <canvas id="outputCanvas" width="600" height="400" style="display: block; margin: 0 auto;"></canvas>
                            <div id="lossValue" class="mt-4 text-lg" style="text-align: center;">
                                Ø§Ù„Ø®Ø³Ø§Ø±Ø© (Loss): <span class="font-bold">---</span>
                            </div>
                            <div class="mt-2 text-sm" style="color: var(--text-muted); font-size: 0.875rem; text-align: center;">
                                <p>Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ù„ÙˆÙ†Ø©: Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©. ØªØ¯Ø±Ø¬ Ø§Ù„Ø®Ù„ÙÙŠØ©: ØªÙ†Ø¨Ø¤Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ© (Ø§Ù„Ø®Ø· Ø§Ù„ÙØ§ØµÙ„ Ù‡Ùˆ 0.5).</p>
                            </div>
                        </div>

                        <!-- Ø¹Ù…ÙˆØ¯ Ø§Ù„Ø´Ø¨ÙƒØ© (Ø§Ù„Ø¢Ù† ÙŠØµØ¨Ø­ Ø§Ù„ØµÙ Ø§Ù„Ø«Ø§Ù†ÙŠ) -->
                        <div class="flex flex-col items-center w-full mx-auto" style="display: flex; flex-direction: column; align-items: center; max-width: 600px;">
                            <h3 style="font-size: 1.25rem;">Ø¨Ù†ÙŠØ© Ø§Ù„Ø´Ø¨ÙƒØ©</h3>
                            <div id="networkVizContainer" class="relative w-full h-96" style="position: relative; width: 100%; height: 24rem; display: flex; justify-content: center;">
                                <svg id="connection-svg" xmlns="http://www.w3.org/2000/svg" style="position: absolute; top: 0; right: 0; width: 100%; height: 100%; z-index: 5;"></svg>
                                <!-- Ø³ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø·Ø¨Ù‚Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ© Ù‡Ù†Ø§ Ø¨ÙˆØ§Ø³Ø·Ø© JavaScript -->
                                <div class="flex justify-between items-center w-full h-full absolute top-0 right-0 p-4" style="display: flex; justify-content: space-around; align-items: center; width: 100%; height: 100%; position: absolute; top: 0; right: 0; padding: 1rem;">
                                    <div class="layer">
                                        <p class="text-center font-semibold mb-2" style="font-weight: 600; font-size: 1rem; color: var(--text-light); margin-bottom: 0.5rem;">Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„</p>
                                        <div class="neuron input-neuron" title="Ø§Ù„Ù…Ø¯Ø®Ù„ Ø§Ù„Ø£ÙˆÙ„ (X1)">X1</div>
                                        <div class="neuron input-neuron" title="Ø§Ù„Ù…Ø¯Ø®Ù„ Ø§Ù„Ø«Ø§Ù†ÙŠ (X2)">X2</div>
                                    </div>
                                    <div class="layer" id="hiddenLayerContainer">
                                        <!-- ØªÙÙ…Ù„Ø£ Ù‡Ù†Ø§ Ø§Ù„Ø¹Ù‚Ø¯ Ø§Ù„Ù…Ø®ÙÙŠØ© Ø¨ÙˆØ§Ø³Ø·Ø© JS -->
                                    </div>
                                    <div class="layer">
                                        <p class="text-center font-semibold mb-2" style="font-weight: 600; font-size: 1rem; color: var(--text-light); margin-bottom: 0.5rem;">Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬</p>
                                        <div class="neuron output-neuron">Y</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- ØªÙ†Ù‚Ù„ Ø¨ÙŠÙ† Ø§Ù„ØªØ¨ÙˆÙŠØ¨Ø§Øª ---
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabPanes = document.querySelectorAll('.tab-pane');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙØ¦Ø© Ø§Ù„Ù†Ø´Ø·Ø© Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø²Ù‡Ø§Ø±
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabPanes.forEach(pane => pane.classList.remove('active'));
                    
                    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙØ¦Ø© Ø§Ù„Ù†Ø´Ø·Ø© Ù„Ù„Ø²Ø± Ø§Ù„Ù…Ø­Ø¯Ø¯
                    button.classList.add('active');
                    const tabId = button.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ù… Ø¨Ø¹Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„ØªØ¨ÙˆÙŠØ¨ (Ø®Ø§Øµ Ø¨Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ©)
                    if (tabId === 'tab-neural-network' && window.drawVisualization) {
                         // ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ù„Ø¶Ù…Ø§Ù† Ø±Ø³Ù… Ø¹Ù†Ø§ØµØ± DOM Ù‚Ø¨Ù„ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª
                        setTimeout(window.drawVisualization, 50); 
                    }
                });
            });

            // --- 1. Ù…Ø­Ø§ÙƒØ§Ø© K-Means ---
            function initKMeans() {
                const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
                const svg = document.getElementById('kmeans-svg');
                const startBtn = document.getElementById('btn-kmeans-start');
                const resetBtn = document.getElementById('btn-kmeans-reset');
                
                const svgWidth = 500;
                const svgHeight = 400;
                const padding = 50;
                
                let points = [];
                let centroids = [];
                let clusters = [];
                let step = 0; // 0: Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†, 1: ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù†Ù‚Ø§Ø·, 2: ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø±Ø§ÙƒØ²
                const k = 3; // Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª
                
                // ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
                function generatePoints() {
                    points = [];
                    for (let i = 0; i < 50; i++) {
                        points.push({
                            x: Math.random() * (svgWidth - 2 * padding) + padding,
                            y: Math.random() * (svgHeight - 2 * padding) + padding
                        });
                    }
                }
                
                // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø±Ø§ÙƒØ² Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
                function initCentroids() {
                    centroids = [];
                    const usedIndices = new Set();
                    
                    while (centroids.length < k) {
                        const idx = Math.floor(Math.random() * points.length);
                        if (!usedIndices.has(idx)) {
                            usedIndices.add(idx);
                            centroids.push({
                                x: points[idx].x,
                                y: points[idx].y,
                                color: getColorForCluster(centroids.length)
                            });
                        }
                    }
                }
                
                // ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù†Ù‚Ø§Ø· Ø¥Ù„Ù‰ Ø£Ù‚Ø±Ø¨ Ù…Ø±ÙƒØ²
                function assignPointsToClusters() {
                    clusters = Array(k).fill().map(() => []);
                    
                    points.forEach(point => {
                        let minDist = Infinity;
                        let closestCentroidIdx = 0;
                        
                        centroids.forEach((centroid, idx) => {
                            const dx = point.x - centroid.x;
                            const dy = point.y - centroid.y;
                            const dist = dx * dx + dy * dy; // Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„ØªØ±Ø¨ÙŠØ¹ÙŠØ©
                            
                            if (dist < minDist) {
                                minDist = dist;
                                closestCentroidIdx = idx;
                            }
                        });
                        
                        clusters[closestCentroidIdx].push(point);
                        point.cluster = closestCentroidIdx;
                    });
                }
                
                // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø±Ø§ÙƒØ²
                function updateCentroids() {
                    let hasMoved = false;
                    
                    centroids.forEach((centroid, idx) => {
                        const clusterPoints = clusters[idx];
                        if (clusterPoints.length === 0) return;
                        
                        const sum = clusterPoints.reduce((acc, p) => ({
                            x: acc.x + p.x,
                            y: acc.y + p.y
                        }), { x: 0, y: 0 });
                        
                        const newX = sum.x / clusterPoints.length;
                        const newY = sum.y / clusterPoints.length;
                        
                        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø±ÙƒØ² Ù‚Ø¯ ØªØ­Ø±Ùƒ Ø¨Ø´ÙƒÙ„ ÙƒØ¨ÙŠØ±
                        const dx = newX - centroid.x;
                        const dy = newY - centroid.y;
                        if (dx * dx + dy * dy > 1) {
                            hasMoved = true;
                        }
                        
                        centroid.x = newX;
                        centroid.y = newY;
                    });
                    
                    return hasMoved;
                }
                
                // Ø±Ø³Ù… Ø§Ù„Ù…Ø´Ù‡Ø¯
                function draw() {
                    // Ù…Ø³Ø­ SVG
                    svg.innerHTML = '';
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù…Ù†Ø§Ø·Ù‚ (Voronoi cells Ù…Ø¨Ø³Ø·Ø©)
                    if (step > 0) {
                        centroids.forEach((centroid, idx) => {
                            // Ø±Ø³Ù… Ù…Ù†Ø·Ù‚Ø© ØªÙ‚Ø±ÙŠØ¨ÙŠØ© (ÙÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹ØŒ Ù‡Ø°Ø§ Ù„ÙŠØ³ Voronoi Ø­Ù‚ÙŠÙ‚ÙŠ)
                            const area = document.createElementNS(SVG_NAMESPACE, 'circle');
                            area.setAttribute('cx', centroid.x);
                            area.setAttribute('cy', centroid.y);
                            area.setAttribute('r', 150);
                            area.setAttribute('fill', centroid.color);
                            area.setAttribute('opacity', 0.1);
                            area.setAttribute('class', 'cluster-area');
                            svg.appendChild(area);
                        });
                    }
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù†Ù‚Ø§Ø·
                    points.forEach(point => {
                        const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
                        circle.setAttribute('cx', point.x);
                        circle.setAttribute('cy', point.y);
                        circle.setAttribute('r', 5);
                        circle.setAttribute('fill', centroids[point.cluster]?.color || '#999');
                        svg.appendChild(circle);
                    });
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù…Ø±Ø§ÙƒØ²
                    centroids.forEach((centroid, idx) => {
                        const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
                        circle.setAttribute('cx', centroid.x);
                        circle.setAttribute('cy', centroid.y);
                        circle.setAttribute('r', 10);
                        circle.setAttribute('fill', centroid.color);
                        circle.setAttribute('class', 'centroid');
                        svg.appendChild(circle);
                        
                        // Ø¥Ø¶Ø§ÙØ© Ø±Ù‚Ù… Ù„Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
                        const text = document.createElementNS(SVG_NAMESPACE, 'text');
                        text.setAttribute('x', centroid.x + 15);
                        text.setAttribute('y', centroid.y + 5);
                        text.setAttribute('fill', 'white');
                        text.setAttribute('font-size', '12');
                        text.setAttribute('font-weight', 'bold');
                        text.textContent = `Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© ${idx + 1}`;
                        svg.appendChild(text);
                    });
                }
                
                // Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©
                function nextStep() {
                    if (step === 0) {
                        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†
                        generatePoints();
                        initCentroids();
                        assignPointsToClusters();
                        step = 1;
                        startBtn.textContent = 'Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ©';
                    } else if (step === 1) {
                        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø±Ø§ÙƒØ²
                        const hasMoved = updateCentroids();
                        assignPointsToClusters();
                        if (!hasMoved) {
                            startBtn.textContent = 'Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡! Ø§Ø¶ØºØ· Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„';
                            startBtn.disabled = false;
                            step = 0;
                            return;
                        }
                    }
                    
                    draw();
                    startBtn.disabled = false;
                }
                
                // Ù…Ø¹Ø§ÙˆØ¯Ø© Ø§Ù„Ø¶Ø¨Ø·
                function reset() {
                    step = 0;
                    startBtn.textContent = 'Ø§Ø¨Ø¯Ø£';
                    startBtn.disabled = false;
                    nextStep();
                }
                
                // Ù…Ø³Ø§Ø¹Ø¯: Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù„ÙˆÙ† Ù„ÙƒÙ„ Ù…Ø¬Ù…ÙˆØ¹Ø©
                function getColorForCluster(idx) {
                    const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6'];
                    return colors[idx % colors.length];
                }
                
                // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
                startBtn.addEventListener('click', () => {
                    startBtn.disabled = true;
                    nextStep();
                });
                
                resetBtn.addEventListener('click', reset);
                
                // Ø§Ù„Ø¨Ø¯Ø¡
                reset();
            }
            
            // --- 2. Ù…Ø­Ø§ÙƒØ§Ø© Classification ---
            function initClassification() {
                const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
                const svg = document.getElementById('class-svg');
                const generateBtn = document.getElementById('btn-class-generate');
                const svgWidth = 500;
                const svgHeight = 400;
                const padding = 50;
                
                const CLASS_COLORS = {
                    0: getComputedStyle(document.documentElement).getPropertyValue('--cluster-2'), // Ø£Ø­Ù…Ø±
                    1: getComputedStyle(document.documentElement).getPropertyValue('--cluster-1')   // Ø£Ø®Ø¶Ø±
                };
                
                function generateAndDraw() {
                    svg.innerHTML = '';
                    
                    // ØªÙˆÙ„ÙŠØ¯ Ù…Ø¬Ù…ÙˆØ¹ØªÙŠÙ† Ù…Ù† Ø§Ù„Ù†Ù‚Ø§Ø·
                    const dataPoints = [];
                    const numPointsPerClass = 30;
                    
                    // Ø§Ù„ÙØ¦Ø© 0 (ÙŠØ³Ø§Ø±)
                    for (let i = 0; i < numPointsPerClass; i++) {
                        dataPoints.push({
                            x: Math.random() * (svgWidth / 2 - 2 * padding) + padding,
                            y: Math.random() * (svgHeight - 2 * padding) + padding,
                            class: 0
                        });
                    }
                    
                    // Ø§Ù„ÙØ¦Ø© 1 (ÙŠÙ…ÙŠÙ†)
                    for (let i = 0; i < numPointsPerClass; i++) {
                        dataPoints.push({
                            x: Math.random() * (svgWidth / 2 - 2 * padding) + svgWidth / 2 + padding,
                            y: Math.random() * (svgHeight - 2 * padding) + padding,
                            class: 1
                        });
                    }
                    
                    // Ø­Ø³Ø§Ø¨ Ù…Ø±ÙƒØ² ÙƒÙ„ ÙØ¦Ø©
                    const class0Center = { x: 0, y: 0 };
                    const class1Center = { x: 0, y: 0 };
                    let class0Count = 0, class1Count = 0;
                    
                    dataPoints.forEach(p => {
                        if (p.class === 0) {
                            class0Center.x += p.x;
                            class0Center.y += p.y;
                            class0Count++;
                        } else {
                            class1Center.x += p.x;
                            class1Center.y += p.y;
                            class1Count++;
                        }
                    });
                    
                    if (class0Count > 0) {
                        class0Center.x /= class0Count;
                        class0Center.y /= class0Count;
                    }
                    
                    if (class1Count > 0) {
                        class1Center.x /= class1Count;
                        class1Center.y /= class1Count;
                    }
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù†Ù‚Ø§Ø·
                    dataPoints.forEach(point => {
                        const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
                        circle.setAttribute('cx', point.x);
                        circle.setAttribute('cy', point.y);
                        circle.setAttribute('r', 8);
                        circle.style.fill = CLASS_COLORS[point.class];
                        svg.appendChild(circle);
                    });
                    
                    // Ø±Ø³Ù… Ø®Ø· ÙØ§ØµÙ„ (Ø¨Ø³ÙŠØ·)
                    const midX = (class0Center.x + class1Center.x) / 2;
                    const midY = (class0Center.y + class1Center.y) / 2;
                    let slope = -1 / ((class1Center.y - class0Center.y) / (class1Center.x - class0Center.x));
                    
                    const x1 = 0;
                    const y1 = midY - slope * midX;
                    const x2 = svgWidth;
                    const y2 = midY + slope * (svgWidth - midX);
                    
                    const line = document.createElementNS(SVG_NAMESPACE, 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('class', 'class-decision-boundary');
                    svg.appendChild(line);
                }
                
                generateBtn.addEventListener('click', generateAndDraw);
                generateAndDraw(); // Ù„Ù„Ø±Ø³Ù… Ø£ÙˆÙ„ Ù…Ø±Ø©
            }
            
            // --- 3. Ù…Ø­Ø§ÙƒØ§Ø© Regression ---
            function initRegression() {
                const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
                const svg = document.getElementById('reg-svg');
                const generateBtn = document.getElementById('btn-reg-generate');
                const svgWidth = 500;
                const svgHeight = 400;
                const padding = 50;
                
                function generateAndDraw() {
                    svg.innerHTML = '';
                    let dataPoints = [];
                    const numPoints = 20;
                    const noiseLevel = 80;
                    
                    // Ù…ÙŠÙ„ Ø§Ù„Ø®Ø· (Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù‚Ù„ÙŠÙ„Ø§Ù‹)
                    const m_true = (Math.random() - 0.5) * 0.5 + 0.5; // Ù…ÙŠÙ„ Ù…ÙˆØ¬Ø¨
                    const b_true = Math.random() * (svgHeight / 4) + (svgHeight / 4);
                    
                    // ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù†Ù‚Ø§Ø·
                    for (let i = 0; i < numPoints; i++) {
                        const x = Math.random() * (svgWidth - 2 * padding) + padding;
                        const y_true = m_true * x + b_true;
                        const noise = (Math.random() - 0.5) * noiseLevel;
                        dataPoints.push({ x: x, y: y_true + noise });
                    }
                    
                    // Ø­Ø³Ø§Ø¨ Ø®Ø· Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø±
                    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                    dataPoints.forEach(p => {
                        sumX += p.x;
                        sumY += p.y;
                        sumXY += p.x * p.y;
                        sumX2 += p.x * p.x;
                    });
                    
                    const n = dataPoints.length;
                    const m = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                    const b = (sumY - m * sumX) / n;
                    
                    const x1 = 0;
                    const y1 = m * x1 + b;
                    const x2 = svgWidth;
                    const y2 = m * x2 + b;
                    
                    // Ø±Ø³Ù… Ø§Ù„Ø®Ø·
                    const line = document.createElementNS(SVG_NAMESPACE, 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('class', 'reg-line');
                    svg.appendChild(line);

                    // Ø±Ø³Ù… Ø§Ù„Ù†Ù‚Ø§Ø·
                    dataPoints.forEach(point => {
                        const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
                        circle.setAttribute('cx', point.x);
                        circle.setAttribute('cy', point.y);
                        circle.setAttribute('r', 6);
                        circle.setAttribute('class', 'reg-point');
                        svg.appendChild(circle);
                    });
                }
                
                generateBtn.addEventListener('click', generateAndDraw);
                generateAndDraw();
            }
            
            // --- 4. Ù…Ø­Ø§ÙƒØ§Ø© Dimensionality Reduction ---
            function initDimRed() {
                const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
                const svgMain = document.getElementById('dimred-svg-main');
                const svgXY = document.getElementById('dimred-svg-xy');
                const svgYZ = document.getElementById('dimred-svg-yz');
                
                // Helper to draw a projection onto a 2D SVG plane
                function drawProjection(svg, projectionName, data) {
                    svg.innerHTML = '';
                    const width = svg.clientWidth;
                    const height = svg.clientHeight;
                    
                    // Simple axis representation
                    const lineX = document.createElementNS(SVG_NAMESPACE, 'line');
                    lineX.setAttribute('x1', 10); lineX.setAttribute('y1', height - 10);
                    lineX.setAttribute('x2', width - 10); lineX.setAttribute('y2', height - 10);
                    lineX.setAttribute('stroke', 'var(--text-light)'); lineX.setAttribute('stroke-width', 1);
                    svg.appendChild(lineX);
                    
                    const lineY = document.createElementNS(SVG_NAMESPACE, 'line');
                    lineY.setAttribute('x1', 10); lineY.setAttribute('y1', 10);
                    lineY.setAttribute('x2', 10); lineY.setAttribute('y2', height - 10);
                    lineY.setAttribute('stroke', 'var(--text-light)'); lineY.setAttribute('stroke-width', 1);
                    svg.appendChild(lineY);

                    // Add dummy data points (for illustration)
                    data.forEach(p => {
                        const x = p[0];
                        const y = p[1];
                        let cx, cy;
                        
                        // Map coordinates based on projection (simple scaling)
                        if (projectionName === 'X-Y') {
                            cx = 10 + (x + 1) * (width - 20) / 2; // Map X from -1 to 1 to 10 to width-10
                            cy = height - 10 - (y + 1) * (height - 20) / 2; // Map Y from -1 to 1 to height-10 to 10
                        } else if (projectionName === 'Y-Z') {
                            cx = 10 + (p[2] + 1) * (width - 20) / 2; // Z as X-axis
                            cy = height - 10 - (y + 1) * (height - 20) / 2; // Y as Y-axis
                        }
                        
                        const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
                        circle.setAttribute('cx', cx);
                        circle.setAttribute('cy', cy);
                        circle.setAttribute('r', 5);
                        circle.setAttribute('fill', 'var(--data-point-color)');
                        svg.appendChild(circle);
                    });
                }
                
                // Generate simple 3D data (a spiral or a cluster)
                const data3D = [];
                for (let i = 0; i < 20; i++) {
                    const t = i / 20 * Math.PI * 4;
                    const x = Math.sin(t) * 0.5 + Math.random() * 0.1;
                    const y = Math.cos(t) * 0.5 + Math.random() * 0.1;
                    const z = i / 20 * 0.8 + Math.random() * 0.1;
                    data3D.push([x, y, z]);
                }

                // Simulate drawing 3D data (just conceptual)
                function draw3DView(svg) {
                    svg.innerHTML = ''; // Clear main view
                    // Draw a conceptual box for 3D axes
                    const box = document.createElementNS(SVG_NAMESPACE, 'rect');
                    box.setAttribute('x', 50); box.setAttribute('y', 50);
                    box.setAttribute('width', 200); box.setAttribute('height', 200);
                    box.setAttribute('fill', 'none');
                    box.setAttribute('stroke', 'var(--border-color)');
                    box.setAttribute('stroke-width', 1);
                    svg.appendChild(box);
                    
                    // Draw conceptual 3D spiral (just a line)
                    const path = document.createElementNS(SVG_NAMESPACE, 'path');
                    let d = `M ${150 + data3D[0][0]*50} ${150 + data3D[0][1]*50}`;
                    data3D.forEach(p => {
                        // Very rough projection: X+Z for x, Y-Z for y
                         d += ` L ${150 + (p[0] + p[2])*70} ${150 + (p[1] - p[2])*70}`;
                    });
                    path.setAttribute('d', d);
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', 'var(--data-point-color)');
                    path.setAttribute('stroke-width', 2);
                    svg.appendChild(path);
                }

                // Initial draw for all views
                draw3DView(svgMain);
                drawProjection(svgXY, 'X-Y', data3D);
                drawProjection(svgYZ, 'Y-Z', data3D);

                // Re-draw on resize might be complex for 3D, so we omit event listener.
            }

            // --- 5. Ù…Ø­Ø§ÙƒØ§Ø© Association Rules ---
            function initAssocRules() {
                const itemButtons = document.querySelectorAll('.assoc-item-btn');
                const cartItemsContainer = document.getElementById('assoc-cart-items');
                const suggestionBox = document.getElementById('assoc-suggestion-box');
                const resetBtn = document.getElementById('assoc-reset-btn');
                
                let cart = new Set();
                const rules = { 'bread': 'milk', 'chips': 'soda' };
                const itemEmojis = {
                    'bread': 'ğŸ', 'milk': 'ğŸ¥›', 'chips': 'ğŸ¥¨',
                    'soda': 'ğŸ¥¤', 'eggs': 'ğŸ¥š', 'apple': 'ğŸ'
                };

                function updateCartView() {
                    cartItemsContainer.innerHTML = '';
                    if (cart.size === 0) {
                        cartItemsContainer.innerHTML = '';
                    } else {
                        cart.forEach(item => {
                            const span = document.createElement('span');
                            span.textContent = itemEmojis[item] || item;
                            cartItemsContainer.appendChild(span);
                        });
                    }
                    checkRules();
                }

                function checkRules() {
                    let suggestionFound = false;
                    for (const antecedent in rules) {
                        if (cart.has(antecedent)) {
                            const consequent = rules[antecedent];
                            if (!cart.has(consequent)) {
                                showSuggestion(antecedent, consequent);
                                suggestionFound = true;
                                break;
                            }
                        }
                    }
                    if (!suggestionFound) clearSuggestion();
                }

                function showSuggestion(itemA, itemB) {
                    suggestionBox.classList.add('active');
                    suggestionBox.innerHTML = `
                        <div class="assoc-suggestion-content">
                            Ù„Ø£Ù†Ùƒ Ø§Ø´ØªØ±ÙŠØª ${itemEmojis[itemA]}...
                            <span class="emoji">${itemEmojis[itemB]}</span>
                            Ù‚Ø¯ ØªØ±ØºØ¨ Ø£ÙŠØ¶Ø§Ù‹ ÙÙŠ Ø´Ø±Ø§Ø¡ ${itemEmojis[itemB]}!
                        </div>
                    `;
                }

                function clearSuggestion() {
                    suggestionBox.classList.remove('active');
                    suggestionBox.innerHTML = '<span>Ø£Ø¶Ù Ù…Ù†ØªØ¬Ø§Øª Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª...</span>';
                }

                itemButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        cart.add(button.dataset.id);
                        updateCartView();
                    });
                });

                resetBtn.addEventListener('click', () => {
                    cart.clear();
                    updateCartView();
                });
                
                updateCartView();
            }

            // --- 6. Ù…Ø­Ø§ÙƒØ§Ø© Bias-Variance ---
            function initBiasVariance() {
                const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
                const svg = document.getElementById('bv-svg');
                const btnUnderfit = document.getElementById('btn-bv-underfit');
                const btnGoodfit = document.getElementById('btn-bv-goodfit');
                const btnOverfit = document.getElementById('btn-bv-overfit');
                const btnNewData = document.getElementById('btn-bv-new-data');
                const buttons = [btnUnderfit, btnGoodfit, btnOverfit];
                
                const svgWidth = 500;
                const svgHeight = 400;
                const padding = 50;
                const numPoints = 15;
                
                let dataPoints = [];
                let currentFit = 'goodfit';
                
                // Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© (Ø§Ù„ØªÙŠ Ù„Ø§ Ù†Ø±Ø§Ù‡Ø§)
                function trueFunction(x) {
                    let normalizedX = (x - (svgWidth / 2)) / (svgWidth / 3);
                    return (normalizedX * normalizedX) * (svgHeight / 4) + (svgHeight / 3);
                }
                
                function generateDataPoints() {
                    dataPoints = [];
                    const noiseLevel = svgHeight / 6;
                    for (let i = 0; i < numPoints; i++) {
                        const x = Math.random() * (svgWidth - 2 * padding) + padding;
                        const trueY = trueFunction(x);
                        const noise = (Math.random() - 0.5) * noiseLevel;
                        const y = Math.max(padding, Math.min(svgHeight - padding, trueY + noise));
                        dataPoints.push({ x: x, y: y });
                    }
                }

                function drawDataPoints() {
                    svg.querySelectorAll('.data-point').forEach(p => p.remove());
                    dataPoints.forEach(point => {
                        const circle = document.createElementNS(SVG_NAMESPACE, 'circle');
                        circle.setAttribute('cx', point.x);
                        circle.setAttribute('cy', point.y);
                        circle.setAttribute('r', 5);
                        circle.setAttribute('class', 'data-point');
                        circle.style.fill = 'var(--data-point-color)';
                        svg.appendChild(circle);
                    });
                }

                function createLine(d, color) {
                    svg.querySelectorAll('.bv-model-line').forEach(l => l.remove());
                    const path = document.createElementNS(SVG_NAMESPACE, 'path');
                    path.setAttribute('d', d);
                    path.setAttribute('stroke', color);
                    path.setAttribute('class', 'bv-model-line');
                    svg.appendChild(path);
                }
                
                // Ù†Ù…ÙˆØ°Ø¬ Ø¨Ø³ÙŠØ· (High Bias)
                function drawUnderfitLine() {
                    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                    dataPoints.forEach(p => { sumX += p.x; sumY += p.y; sumXY += p.x * p.y; sumX2 += p.x * p.x; });
                    const n = dataPoints.length;
                    const m = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                    const b = (sumY - m * sumX) / n;
                    const d = `M 0 ${m * 0 + b} L ${svgWidth} ${m * svgWidth + b}`;
                    createLine(d, 'var(--cluster-2)'); // Ø£Ø­Ù…Ø±
                }
                
                // Ù†Ù…ÙˆØ°Ø¬ Ù…Ù„Ø§Ø¦Ù…
                function drawGoodFitLine() {
                    // Ù†Ø±Ø³Ù… Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© ÙƒØ£Ù†Ù†Ø§ Ù†Ø¹Ø±ÙÙ‡Ø§
                    let d = `M ${padding} ${trueFunction(padding)}`;
                    for (let x = padding + 10; x <= svgWidth - padding; x += 10) {
                        d += ` L ${x} ${trueFunction(x)}`;
                    }
                    createLine(d, 'var(--cluster-1)'); // Ø£Ø®Ø¶Ø±
                }

                // Ù†Ù…ÙˆØ°Ø¬ Ù…Ø¹Ù‚Ø¯ (High Variance)
                function drawOverfitLine() {
                    const sortedPoints = [...dataPoints].sort((a, b) => a.x - b.x);
                    if (sortedPoints.length === 0) return;
                    
                    let d = `M ${sortedPoints[0].x} ${sortedPoints[0].y}`;
                    let p = [];
                    for (let point of sortedPoints) { p.push(point.x, point.y); }

                    for (let i = 0; i < p.length - 2; i += 2) {
                         let x0 = i ? p[i - 2] : p[0];
                         let y0 = i ? p[i - 1] : p[1];
                         let x1 = p[i];
                         let y1 = p[i + 1];
                         let x2 = p[i + 2];
                         let y2 = p[i + 3];
                         let x3 = i + 4 < p.length ? p[i + 4] : x2;
                         let y3 = i + 5 < p.length ? p[i + 5] : y2;
                         let cp1x = x1 + (x2 - x0) / 6;
                         let cp1y = y1 + (y2 - y0) / 6;
                         let cp2x = x2 - (x3 - x1) / 6;
                         let cp2y = y2 - (y3 - y1) / 6;
                         d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
                    }
                    createLine(d, 'var(--cluster-3)'); // Ø£ØµÙØ±
                }

                function updateFit() {
                    if (currentFit === 'underfit') drawUnderfitLine();
                    else if (currentFit === 'goodfit') drawGoodFitLine();
                    else if (currentFit === 'overfit') drawOverfitLine();
                }
                
                function setActiveButton(activeBtn) {
                    buttons.forEach(btn => btn.classList.remove('active'));
                    activeBtn.classList.add('active');
                }

                buttons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        currentFit = btn.id.split('-')[2]; // 'underfit', 'goodfit', 'overfit'
                        setActiveButton(btn);
                        updateFit();
                    });
                });
                
                btnNewData.addEventListener('click', () => {
                    generateDataPoints();
                    drawDataPoints();
                    updateFit();
                });

                // Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø£ÙˆÙ„ÙŠ
                generateDataPoints();
                drawDataPoints();
                updateFit();
            }

            // --- 7. Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ© (Neural Network) ---

            // Ø¯Ø§Ù„Ø© ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© ÙÙŠ Ù†Ø·Ø§Ù‚ Ù…Ø¹ÙŠÙ†
            const random = (min, max) => Math.random() * (max - min) + min;

            // Ø¯Ø§Ù„Ø© ØªÙØ¹ÙŠÙ„ Sigmoid
            const sigmoid = (x) => 1 / (1 + Math.exp(-x));

            // Ø¯Ø§Ù„Ø© Ù…Ø´ØªÙ‚Ø© Sigmoid
            const sigmoidDerivative = (y) => y * (1 - y);

            // --- Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠØ© ---
            let isTraining = false;
            let epoch = 0;
            let network;
            let data;
            let canvas;
            let ctx;
            const CANVAS_WIDTH = 600;
            const CANVAS_HEIGHT = 400;
            
            // --- Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„ØªØµÙˆØ± ---

            // ØªØ­ÙˆÙŠÙ„ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Canvas
            function scaleX(x) { return (x + 3) * (CANVAS_WIDTH / 6); }
            function scaleY(y) { return CANVAS_HEIGHT - ((y + 2) * (CANVAS_HEIGHT / 4)); }
            
            // --- Ø¯Ø§Ù„Ø© ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ---
            function generateData() {
                const dataPoints = [];
                const numPoints = 100;

                for (let i = 0; i < numPoints; i++) {
                    let x1, x2, label;
                    
                    // ØªÙˆÙ„ÙŠØ¯ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù„Ù…Ø«Ø§Ù„ÙŠÙ† Ø¨Ø³ÙŠØ·ÙŠÙ† (ÙØµÙ„ Ø®Ø·ÙŠ ØªÙ‚Ø±ÙŠØ¨ÙŠ)
                    if (Math.random() > 0.5) {
                        // Ø§Ù„ÙØ¦Ø© 0 (Ø£Ø­Ù…Ø±) - Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø£ÙŠÙ…Ù† Ø§Ù„Ø³ÙÙ„ÙŠ
                        x1 = random(0, 3);
                        x2 = random(-2, 0);
                        label = 0;
                    } else {
                        // Ø§Ù„ÙØ¦Ø© 1 (Ø£Ø®Ø¶Ø±) - Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ø£ÙŠØ³Ø± Ø§Ù„Ø¹Ù„ÙˆÙŠ
                        x1 = random(-3, 0);
                        x2 = random(0, 2);
                        label = 1;
                    }
                    
                    // Ø¥Ø¶Ø§ÙØ© Ø¶ÙˆØ¶Ø§Ø¡ Ø¨Ø³ÙŠØ·Ø©
                    x1 += random(-0.5, 0.5);
                    x2 += random(-0.5, 0.5);

                    dataPoints.push({
                        inputs: [x1, x2],
                        target: label
                    });
                }
                return dataPoints;
            }

            // --- Ø¨Ù†ÙŠØ© Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ© (Ø§Ù„ÙƒØ§Ø¦Ù†) ---
            class NeuralNetwork {
                constructor(inputNodes, hiddenNodes, outputNodes) {
                    this.inputNodes = inputNodes;
                    this.hiddenNodes = hiddenNodes;
                    this.outputNodes = outputNodes;

                    // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…ØµÙÙˆÙØ§Øª Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø£ÙˆØ²Ø§Ù† ÙˆØ§Ù„Ø§Ù†Ø­ÙŠØ§Ø²Ø§Øª
                    this.weights_ih = this.createMatrix(hiddenNodes, inputNodes); // Ø£ÙˆØ²Ø§Ù† Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø®ÙÙŠØ©
                    this.weights_ho = this.createMatrix(outputNodes, hiddenNodes); // Ø£ÙˆØ²Ø§Ù† Ø§Ù„Ù…Ø®ÙÙŠØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬
                    
                    this.bias_h = this.createVector(hiddenNodes); // Ø§Ù†Ø­ÙŠØ§Ø²Ø§Øª Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ø®ÙÙŠØ©
                    this.bias_o = this.createVector(outputNodes); // Ø§Ù†Ø­ÙŠØ§Ø²Ø§Øª Ø·Ø¨Ù‚Ø© Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬

                    this.randomizeMatrices();
                }
                
                // Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© (Array of Arrays)
                createMatrix(rows, cols) {
                    return Array(rows).fill(0).map(() => Array(cols).fill(0));
                }

                // Ø¥Ù†Ø´Ø§Ø¡ Ù…ØªØ¬Ù‡ (Array)
                createVector(size) {
                    return Array(size).fill(0);
                }

                // ØªØ¹ÙŠÙŠÙ† Ù‚ÙŠÙ… Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© ØµØºÙŠØ±Ø© Ù„Ù„Ø£ÙˆØ²Ø§Ù† ÙˆØ§Ù„Ø§Ù†Ø­ÙŠØ§Ø²Ø§Øª
                randomizeMatrices() {
                    const randomize = (matrix) => {
                        for (let i = 0; i < matrix.length; i++) {
                            for (let j = 0; j < matrix[i].length; j++) {
                                matrix[i][j] = random(-1, 1);
                            }
                        }
                    };
                    randomize(this.weights_ih);
                    randomize(this.weights_ho);
                    
                    // Ø§Ù„Ø§Ù†Ø­ÙŠØ§Ø²Ø§Øª
                    for (let i = 0; i < this.bias_h.length; i++) this.bias_h[i] = random(-1, 1);
                    for (let i = 0; i < this.bias_o.length; i++) this.bias_o[i] = random(-1, 1);
                }

                // --- Ø¯Ø§Ù„Ø© Ø§Ù„ØªØºØ°ÙŠØ© Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ© (Feedforward) ---
                feedforward(inputArray) {
                    // 1. Ø­Ø³Ø§Ø¨ Ù…Ø®Ø±Ø¬Ø§Øª Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ø®ÙÙŠØ©
                    const inputs = inputArray;
                    const hidden_outputs = this.createVector(this.hiddenNodes);

                    for (let i = 0; i < this.hiddenNodes; i++) {
                        let sum = 0;
                        // Ø¶Ø±Ø¨ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ÙÙŠ Ø£ÙˆØ²Ø§Ù†Ù‡Ø§
                        for (let j = 0; j < this.inputNodes; j++) {
                            sum += inputs[j] * this.weights_ih[i][j];
                        }
                        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø§Ù†Ø­ÙŠØ§Ø²
                        sum += this.bias_h[i];
                        // ØªØ·Ø¨ÙŠÙ‚ Ø¯Ø§Ù„Ø© Ø§Ù„ØªÙØ¹ÙŠÙ„
                        hidden_outputs[i] = sigmoid(sum);
                    }

                    // 2. Ø­Ø³Ø§Ø¨ Ù…Ø®Ø±Ø¬Ø§Øª Ø·Ø¨Ù‚Ø© Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬
                    const output_outputs = this.createVector(this.outputNodes);

                    for (let i = 0; i < this.outputNodes; i++) {
                        let sum = 0;
                        // Ø¶Ø±Ø¨ Ù…Ø®Ø±Ø¬Ø§Øª Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ø®ÙÙŠØ© ÙÙŠ Ø£ÙˆØ²Ø§Ù†Ù‡Ø§
                        for (let j = 0; j < this.hiddenNodes; j++) {
                            sum += hidden_outputs[j] * this.weights_ho[i][j];
                        }
                        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø§Ù†Ø­ÙŠØ§Ø²
                        sum += this.bias_o[i];
                        // ØªØ·Ø¨ÙŠÙ‚ Ø¯Ø§Ù„Ø© Ø§Ù„ØªÙØ¹ÙŠÙ„
                        output_outputs[i] = sigmoid(sum);
                    }

                    return {
                        output: output_outputs,
                        hidden_outputs: hidden_outputs
                    };
                }

                // --- Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ¯Ø±ÙŠØ¨ (Ø§Ù„Ø§Ù†ØªØ´Ø§Ø± Ø§Ù„Ø®Ù„ÙÙŠ - Backpropagation) ---
                train(inputArray, targetArray, learningRate) {
                    // 1. Ø§Ù„ØªØºØ°ÙŠØ© Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª
                    const { output, hidden_outputs } = this.feedforward(inputArray);
                    const inputs = inputArray;
                    
                    // 2. Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®Ø·Ø£ (Error) Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ (Ø§Ù„Ø®Ø³Ø§Ø±Ø© = Ø§Ù„Ù‡Ø¯Ù - Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬)
                    const output_errors = this.createVector(this.outputNodes);
                    for (let i = 0; i < this.outputNodes; i++) {
                        output_errors[i] = targetArray[i] - output[i];
                    }

                    // 3. Ø­Ø³Ø§Ø¨ ØªØ¯Ø±Ø¬ (Gradient) Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ø®ÙÙŠØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬
                    // (Error * Ù…Ø´ØªÙ‚Ø© Ø¯Ø§Ù„Ø© Ø§Ù„ØªÙØ¹ÙŠÙ„)
                    const output_gradients = this.createVector(this.outputNodes);
                    for (let i = 0; i < this.outputNodes; i++) {
                        output_gradients[i] = output_errors[i] * sigmoidDerivative(output[i]) * learningRate;
                    }

                    // 4. ØªØ­Ø¯ÙŠØ« Ø£ÙˆØ²Ø§Ù† ÙˆØ§Ù†Ø­ÙŠØ§Ø²Ø§Øª Ø§Ù„Ù…Ø®ÙÙŠØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ (Weights_HO & Bias_O)
                    for (let i = 0; i < this.outputNodes; i++) { // ØµÙÙˆÙ (Ø§Ù„Ø£ÙˆØ²Ø§Ù†)
                        for (let j = 0; j < this.hiddenNodes; j++) { // Ø£Ø¹Ù…Ø¯Ø© (Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª Ø§Ù„Ù…Ø®ÙÙŠØ©)
                            // ØªØºÙŠÙŠØ± Ø§Ù„ÙˆØ²Ù† = Gradient * Ù…Ø®Ø±Ø¬ Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
                            const delta_w = output_gradients[i] * hidden_outputs[j];
                            this.weights_ho[i][j] += delta_w;
                        }
                        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø§Ù†Ø­ÙŠØ§Ø²
                        this.bias_o[i] += output_gradients[i];
                    }

                    // 5. Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®Ø·Ø£ Ù„Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ø®ÙÙŠØ© (Backpropagate Error)
                    const hidden_errors = this.createVector(this.hiddenNodes);
                    for (let i = 0; i < this.hiddenNodes; i++) {
                        let sum = 0;
                        // (Ø§Ù„Ø®Ø·Ø£ Ø§Ù„Ù„Ø§Ø­Ù‚ * Ø§Ù„ÙˆØ²Ù† Ø§Ù„Ù…Ø±ØªØ¨Ø·)
                        for (let j = 0; j < this.outputNodes; j++) {
                            sum += output_errors[j] * this.weights_ho[j][i];
                        }
                        hidden_errors[i] = sum;
                    }
                    
                    // 6. Ø­Ø³Ø§Ø¨ ØªØ¯Ø±Ø¬ Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ø®ÙÙŠØ©
                    const hidden_gradients = this.createVector(this.hiddenNodes);
                    for (let i = 0; i < this.hiddenNodes; i++) {
                        hidden_gradients[i] = hidden_errors[i] * sigmoidDerivative(hidden_outputs[i]) * learningRate;
                    }

                    // 7. ØªØ­Ø¯ÙŠØ« Ø£ÙˆØ²Ø§Ù† ÙˆØ§Ù†Ø­ÙŠØ§Ø²Ø§Øª Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø®ÙÙŠØ© (Weights_IH & Bias_H)
                    for (let i = 0; i < this.hiddenNodes; i++) { // ØµÙÙˆÙ (Ø§Ù„Ø£ÙˆØ²Ø§Ù†)
                        for (let j = 0; j < this.inputNodes; j++) { // Ø£Ø¹Ù…Ø¯Ø© (Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª)
                            // ØªØºÙŠÙŠØ± Ø§Ù„ÙˆØ²Ù† = Gradient * Ù…Ø®Ø±Ø¬ Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
                            const delta_w = hidden_gradients[i] * inputs[j];
                            this.weights_ih[i][j] += delta_w;
                        }
                        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø§Ù†Ø­ÙŠØ§Ø²
                        this.bias_h[i] += hidden_gradients[i];
                    }
                    
                    // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø®Ø·Ø£ Ø§Ù„Ù…Ø·Ù„Ù‚ Ù„ØºØ±Ø¶ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®Ø³Ø§Ø±Ø©
                    return Math.abs(output_errors[0]);
                }
            }
            
            // --- Ø¯Ø§Ù„Ø© ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØµÙˆØ± (Ø§Ù„Ø±Ø³Ù…) ---
            function drawVisualization() {
                if (!network || !ctx || !data) return;

                // Ù…Ø³Ø­ Ø§Ù„Ù€ Canvas
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // 1. Ø±Ø³Ù… Ø®Ø·ÙˆØ· Ø§Ù„Ù‚Ø±Ø§Ø± (Ø§Ù„Ø®Ù„ÙÙŠØ©)
                const resolution = 15;
                let totalLoss = 0;
                let lossCount = 0;
                
                // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ù…Ø³ØªØ®Ù„ØµØ© Ù‚Ø¨Ù„ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
                const secondaryColor = window.varStyles.secondary || '#10b981'; 
                const dangerColor = window.varStyles.danger || '#ef4444'; 

                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        // ØªØ­ÙˆÙŠÙ„ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø¥Ø¯Ø®Ø§Ù„ (Ù…Ù† -3 Ø¥Ù„Ù‰ 3 ÙˆÙ…Ù† -2 Ø¥Ù„Ù‰ 2)
                        const x_norm = (i / resolution) * 6 - 3; // -3 to 3
                        const y_norm = (j / resolution) * 4 - 2; // -2 to 2
                        
                        const result = network.feedforward([x_norm, y_norm]);
                        const prediction = result.output[0];

                        // ØªÙ„ÙˆÙŠÙ† Ù…Ø±Ø¨Ø¹ (Ø§Ù„Ø®Ø³Ø§Ø±Ø© 0: Ø£Ø­Ù…Ø±ØŒ Ø§Ù„Ø®Ø³Ø§Ø±Ø© 1: Ø£Ø®Ø¶Ø±)
                        const alpha = Math.abs(prediction - 0.5) * 2; // Ø´Ø¯Ø© Ø§Ù„Ù„ÙˆÙ†
                        
                        ctx.beginPath();
                        ctx.rect(
                            (i / resolution) * CANVAS_WIDTH,
                            (CANVAS_HEIGHT - (j / resolution) * CANVAS_HEIGHT) - (CANVAS_HEIGHT / resolution), // Ù…Ù‚Ù„ÙˆØ¨ Y
                            CANVAS_WIDTH / resolution,
                            CANVAS_HEIGHT / resolution
                        );
                        
                        // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ù„ÙˆÙ† CSS (Ù…Ø«Ù„ #rrggbb) Ø¥Ù„Ù‰ rgba
                        function hexToRgba(hex, alpha) {
                            const r = parseInt(hex.substring(1, 3), 16);
                            const g = parseInt(hex.substring(3, 5), 16);
                            const b = parseInt(hex.substring(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        }

                        if (prediction < 0.5) {
                            // Ø£Ø­Ù…Ø± (Ø§Ù„ÙØ¦Ø© 0)
                            ctx.fillStyle = hexToRgba(dangerColor, alpha * 0.4 + 0.1); 
                        } else {
                            // Ø£Ø®Ø¶Ø± (Ø§Ù„ÙØ¦Ø© 1)
                            ctx.fillStyle = hexToRgba(secondaryColor, alpha * 0.4 + 0.1); 
                        }
                        ctx.fill();
                    }
                }
                
                // 2. Ø±Ø³Ù… Ù†Ù‚Ø§Ø· Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£ØµÙ„ÙŠØ©
                for (const point of data) {
                    const px = scaleX(point.inputs[0]);
                    const py = scaleY(point.inputs[1]);
                    const colorClass = point.target;

                    ctx.beginPath();
                    ctx.arc(px, py, 5, 0, Math.PI * 2);
                    ctx.fillStyle = (colorClass === 0) ? dangerColor : secondaryColor;
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®Ø³Ø§Ø±Ø© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©
                    const prediction = network.feedforward(point.inputs).output[0];
                    totalLoss += Math.pow(point.target - prediction, 2);
                    lossCount++;
                }
                
                // 3. ØªØ­Ø¯ÙŠØ« Ù‚ÙŠÙ…Ø© Ø§Ù„Ø®Ø³Ø§Ø±Ø©
                const mse = (totalLoss / lossCount).toFixed(4);
                document.getElementById('lossValue').querySelector('span').textContent = mse;

                // 4. ØªØ­Ø¯ÙŠØ« ØªØµÙˆØ± Ø§Ù„Ø´Ø¨ÙƒØ©
                updateNetworkDiagram();
            }
            window.drawVisualization = drawVisualization; // Ø¬Ø¹Ù„Ù‡Ø§ Ù…ØªØ§Ø­Ø© Ù„Ù„ØªÙ†Ù‚Ù„ Ø¨ÙŠÙ† Ø§Ù„ØªØ¨ÙˆÙŠØ¨Ø§Øª

            // --- Ø¯Ø§Ù„Ø© ØªØ­Ø¯ÙŠØ« Ù…Ø®Ø·Ø· Ø§Ù„Ø´Ø¨ÙƒØ© ---
            function updateNetworkDiagram() {
                const svg = document.getElementById('connection-svg');
                const networkContainer = document.getElementById('networkVizContainer');
                
                if (!svg || !networkContainer) return;

                // ÙŠØ¬Ø¨ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ù… Ø¨Ø¹Ø¯ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù…Ø±Ø¦ÙŠØ© ÙˆÙ…ÙˆØ¶ÙˆØ¹Ø©
                if (networkContainer.offsetParent === null) return; 

                svg.innerHTML = '';
                
                const inputNeurons = document.querySelectorAll('.input-neuron');
                const hiddenNeurons = document.querySelectorAll('.hidden-neuron');
                const outputNeurons = document.querySelectorAll('.output-neuron');
                
                if (inputNeurons.length === 0 || !network) return;

                // ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø£ÙˆØ²Ø§Ù† (Ù„Ù„Ø±Ø³Ù…)
                function getPosition(element) {
                    const rect = element.getBoundingClientRect();
                    const containerRect = networkContainer.getBoundingClientRect();
                    return {
                        x: rect.left + rect.width / 2 - containerRect.left,
                        y: rect.top + rect.height / 2 - containerRect.top
                    };
                }

                // ÙˆØ¸ÙŠÙØ© Ø±Ø³Ù… Ø®Ø· (ÙŠÙ…Ø«Ù„ Ø§Ù„ÙˆØ²Ù†)
                function drawConnection(sourcePos, targetPos, weight) {
                    const line = document.createElementNS("http://www.w3.org/2000/svg", 'line');
                    line.setAttribute('x1', sourcePos.x);
                    line.setAttribute('y1', sourcePos.y);
                    line.setAttribute('x2', targetPos.x);
                    line.setAttribute('y2', targetPos.y);
                    
                    // Ø§Ù„Ù„ÙˆÙ† ÙˆØ§Ù„Ø³Ù…Ùƒ ÙŠØ¹ØªÙ…Ø¯Ø§Ù† Ø¹Ù„Ù‰ Ø§Ù„ÙˆØ²Ù†
                    const weightAbs = Math.abs(weight);
                    const color = weight > 0 ? window.varStyles.secondary : window.varStyles.danger;
                    
                    line.setAttribute('stroke', color);
                    line.setAttribute('stroke-width', 1 + weightAbs * 2); // Ø²ÙŠØ§Ø¯Ø© Ø³Ù…Ùƒ Ø§Ù„Ø®Ø· Ù…Ø¹ Ø²ÙŠØ§Ø¯Ø© Ù‚ÙŠÙ…Ø© Ø§Ù„ÙˆØ²Ù†
                    line.setAttribute('opacity', 0.5 + weightAbs * 0.3);

                    svg.appendChild(line);
                }
                
                // ØªØ­Ø¬ÙŠÙ… SVG
                svg.setAttribute('width', networkContainer.clientWidth);
                svg.setAttribute('height', networkContainer.clientHeight);


                // 1. Ø±Ø³Ù… Ø£ÙˆØ²Ø§Ù† Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø®ÙÙŠØ© (IH)
                for (let i = 0; i < network.hiddenNodes; i++) {
                    const hiddenPos = getPosition(hiddenNeurons[i]);
                    for (let j = 0; j < network.inputNodes; j++) {
                        const inputPos = getPosition(inputNeurons[j]);
                        drawConnection(inputPos, hiddenPos, network.weights_ih[i][j]);
                    }
                    
                    // ØªØ­Ø¯ÙŠØ« Ù‚ÙŠÙ…Ø© Ø§Ù„Ø§Ù†Ø­ÙŠØ§Ø² ÙÙŠ Ø§Ù„Ø¹Ù‚Ø¯Ø© Ø§Ù„Ù…Ø®ÙÙŠØ©
                    const biasValue = network.bias_h[i].toFixed(2);
                    hiddenNeurons[i].title = `Ø§Ù†Ø­ÙŠØ§Ø²: ${biasValue}`;
                }

                // 2. Ø±Ø³Ù… Ø£ÙˆØ²Ø§Ù† Ø§Ù„Ù…Ø®ÙÙŠØ© Ø¥Ù„Ù‰ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ (HO)
                for (let i = 0; i < network.outputNodes; i++) {
                    const outputPos = getPosition(outputNeurons[i]);
                    for (let j = 0; j < network.hiddenNodes; j++) {
                        const hiddenPos = getPosition(hiddenNeurons[j]);
                        drawConnection(hiddenPos, outputPos, network.weights_ho[i][j]);
                    }
                    
                    // ØªØ­Ø¯ÙŠØ« Ù‚ÙŠÙ…Ø© Ø§Ù„Ø§Ù†Ø­ÙŠØ§Ø² ÙÙŠ Ø¹Ù‚Ø¯Ø© Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬
                    const biasValue = network.bias_o[i].toFixed(2);
                    outputNeurons[i].title = `Ø§Ù†Ø­ÙŠØ§Ø²: ${biasValue}`;
                }

            }

            // --- Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (Ø§Ù„Ø­Ù„Ù‚Ø©) ---
            function trainLoop() {
                if (!isTraining) return;

                const learningRate = parseFloat(document.getElementById('learningRate').value);
                
                // ØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ø´Ø¨ÙƒØ© Ø¹Ù„Ù‰ ÙƒÙ„ Ù†Ù‚Ø·Ø© Ø¨ÙŠØ§Ù†Ø§Øª (Epoch)
                for (let i = 0; i < data.length; i++) {
                    const point = data[i];
                    // ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙØ© Ù…ØµÙÙˆÙØ© Ù„Ù„Ø¹Ù‚Ø¯Ø© Ø§Ù„ÙˆØ­ÙŠØ¯Ø©
                    const targetArray = [point.target]; 
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£ÙˆØ²Ø§Ù† ÙˆØ§Ù„Ø§Ù†Ø­ÙŠØ§Ø²Ø§Øª Ø¹Ø¨Ø± Ø§Ù„Ø§Ù†ØªØ´Ø§Ø± Ø§Ù„Ø®Ù„ÙÙŠ
                    network.train(point.inputs, targetArray, learningRate);
                }

                epoch++;
                document.getElementById('epochCount').textContent = epoch;
                document.getElementById('status').textContent = 'ÙŠØªØ¯Ø±Ø¨...';
                
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ù… Ø¨Ø¹Ø¯ ÙƒÙ„ Epoch
                drawVisualization();
                
                // Ø¥Ø°Ø§ Ø§Ù†Ø®ÙØ¶ Ø§Ù„Ø®Ø·Ø£ Ø¨Ø¯Ø±Ø¬Ø© ÙƒØ§ÙÙŠØ©ØŒ ÙŠÙ…ÙƒÙ† Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ¯Ø±ÙŠØ¨
                const currentLoss = parseFloat(document.getElementById('lossValue').querySelector('span').textContent);
                if (currentLoss < 0.005 && epoch > 50) {
                        isTraining = false;
                        document.getElementById('status').textContent = 'ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡!';
                        document.getElementById('btnStart').textContent = 'Ø£Ø¹Ø¯ Ø§Ù„ØªØ¯Ø±ÙŠØ¨';
                        return;
                }

                // Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø¨Ø¹Ø¯ ÙØªØ±Ø© Ø²Ù…Ù†ÙŠØ© Ù‚ØµÙŠØ±Ø© (Ù„ØªÙˆØ¶ÙŠØ­ Ø§Ù„Ø­Ø±ÙƒØ©)
                setTimeout(trainLoop, 50); // 50ms ÙØ§ØµÙ„ Ø²Ù…Ù†ÙŠ Ù„Ù„ØªØ­Ø¯ÙŠØ«
            }

            // --- Ø¯Ø§Ù„Ø© ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© ÙˆØ§Ù„Ø´Ø¨ÙƒØ© ---
            function initializeNN() {
                // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ù†Ø§ØµØ± DOM
                const btnStart = document.getElementById('btnStart');
                const btnReset = document.getElementById('btnReset');
                const hiddenNeuronsSelect = document.getElementById('hiddenNeurons');
                const networkContainer = document.getElementById('networkVizContainer');
                canvas = document.getElementById('outputCanvas');
                if (!canvas) return; // Guard clause in case element is not found
                ctx = canvas.getContext('2d');
                
                // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ù€ CSS Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙŠ Canvas (Ù…ÙØ¹Ø¯Ù„ Ù„ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ø£Ø³Ù…Ø§Ø¡ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ)
                window.varStyles = {
                    primary: getComputedStyle(document.documentElement).getPropertyValue('--accent-blue').trim(),
                    secondary: getComputedStyle(document.documentElement).getPropertyValue('--cluster-1').trim(), // Ø§Ù„Ø£Ø®Ø¶Ø±
                    danger: getComputedStyle(document.documentElement).getPropertyValue('--cluster-2').trim(),  // Ø§Ù„Ø£Ø­Ù…Ø±
                };

                // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                data = generateData();
                
                // --- ÙˆØ¸ÙŠÙØ© Ø¨Ù†Ø§Ø¡ Ù…Ø®Ø·Ø· Ø§Ù„Ø´Ø¨ÙƒØ© (Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠÙ‹Ø§) ---
                function buildNetworkDiagram(hiddenCount) {
                    const hiddenLayerContainer = document.getElementById('hiddenLayerContainer');
                    if (!hiddenLayerContainer) return;

                    hiddenLayerContainer.innerHTML = '';
                    
                    // 2. Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ù…Ø®ÙÙŠØ© (N Ø¹Ù‚Ø¯)
                    let hiddenHtml = `<p class="text-center font-semibold mb-2" style="font-weight: 600; font-size: 1rem; color: var(--text-light); margin-bottom: 0.5rem;">Ù…Ø®ÙÙŠØ© (${hiddenCount})</p>`;
                    for(let i = 0; i < hiddenCount; i++) {
                        hiddenHtml += `<div class="neuron hidden-neuron">H${i+1}</div>`;
                    }
                    hiddenLayerContainer.innerHTML = hiddenHtml;
                }

                // --- ÙˆØ¸ÙŠÙØ© Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø´Ø¨ÙƒØ© ---
                function resetNetwork() {
                    isTraining = false;
                    epoch = 0;
                    
                    const hiddenCount = parseInt(hiddenNeuronsSelect.value);
                    buildNetworkDiagram(hiddenCount);

                    // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ©
                    network = new NeuralNetwork(2, hiddenCount, 1);
                    
                    document.getElementById('epochCount').textContent = 0;
                    document.getElementById('status').textContent = 'Ù…ØªÙˆÙ‚Ù';
                    document.getElementById('btnStart').innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ml-2" viewBox="0 0 20 20" fill="currentColor" style="width: 1.25rem; height: 1.25rem; margin-left: 0.5rem; display: inline-block;">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                        </svg>
                        Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¯Ø±ÙŠØ¨
                    `;
                    
                    // Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø£ÙˆÙ„ÙŠ (Ù…Ø¤Ø¬Ù„ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¶Ø¹ Ø§Ù„Ø¹Ù†Ø§ØµØ±)
                    setTimeout(drawVisualization, 50);
                }

                // --- Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ---
                btnStart.addEventListener('click', () => {
                    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ù‚Ø¯ Ø§Ù†ØªÙ‡Ù‰ Ø¨Ù†Ø¬Ø§Ø­ØŒ Ø£Ø¹Ø¯ Ø§Ù„ØªØ¹ÙŠÙŠÙ† ÙˆØ§Ø¨Ø¯Ø£ Ù…Ù† Ø¬Ø¯ÙŠØ¯
                    const lossElement = document.getElementById('lossValue').querySelector('span');
                    const currentLoss = parseFloat(lossElement.textContent);
                    
                    if (currentLoss < 0.005 && epoch > 50) {
                        resetNetwork();
                        // Ø¨Ø¹Ø¯ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†ØŒ Ø³Ù†Ø¨Ø¯Ø£ Ø§Ù„ØªØ¯Ø±ÙŠØ¨ ÙÙŠ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©
                    }
                    
                    isTraining = !isTraining;
                    if (isTraining) {
                        trainLoop();
                        document.getElementById('btnStart').innerHTML = `
                             <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ml-2" viewBox="0 0 20 20" fill="currentColor" style="width: 1.25rem; height: 1.25rem; margin-left: 0.5rem; display: inline-block;">
                                 <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-9-4a1 1 0 00-1 1v4a1 1 102 0V7a1 1 0 00-1-1zm3 0a1 1 0 00-1 1v4a1 1 0 102 0V7a1 1 0 00-1-1z" clip-rule="evenodd" />
                             </svg>
                             Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª
                        `;
                        document.getElementById('status').textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø¯Ø¡...';
                    } else {
                        document.getElementById('btnStart').innerHTML = `
                             <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ml-2" viewBox="0 0 20 20" fill="currentColor" style="width: 1.25rem; height: 1.25rem; margin-left: 0.5rem; display: inline-block;">
                                 <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                             </svg>
                             Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„ØªØ¯Ø±ÙŠØ¨
                        `;
                        document.getElementById('status').textContent = 'Ù…ØªÙˆÙ‚Ù Ù…Ø¤Ù‚ØªÙ‹Ø§';
                    }
                });

                btnReset.addEventListener('click', resetNetwork);
                
                // ØªØºÙŠÙŠØ± Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù‚Ø¯ Ø§Ù„Ù…Ø®ÙÙŠØ©
                hiddenNeuronsSelect.addEventListener('change', resetNetwork);

                // Ø­Ø¯Ø« ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø© (Ù„ØªØµØ­ÙŠØ­ Ø®Ø·ÙˆØ· SVG)
                window.addEventListener('resize', drawVisualization); 
                
                // Ø§Ù„Ø¨Ø¯Ø¡ Ø¨Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©
                resetNetwork();
            }

            // --- ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø¯ÙˆØ§Ù„ Ø§Ù„ØªÙ‡ÙŠØ¦Ø© ---
            initKMeans();
            initClassification();
            initRegression();
            initDimRed();
            initAssocRules();
            initBiasVariance();
            initializeNN(); // ØªØ´ØºÙŠÙ„ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ©
        });
    </script>
</body>
</html>
